(*^::[	frontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.1";	macintoshStandardFontEncoding; 	paletteColors = 128; localKernel; 	fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, a2, e2,  24, "Helvetica"; ;	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, M7, italic, a2, e2,  10, "Helvetica"; ;	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, M7, a2, e2,  9, "Helvetica"; ;	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, R21845, G21845, B21845, a2, e2,  18, "Helvetica"; ;	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, a2, e2,  14, "Helvetica"; ;	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, a2, e2,  12, "Helvetica"; ;	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; ;	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-5, a2, e2,  10, "Courier"; ;	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a2, e2,  10, "Courier"; ;	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R65535, L-5, a2, e2,  10, "Courier"; ;	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a2, e2,  10, "Courier"; ;	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B65535, L-5, a2, e2,  10, "Courier"; ;	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, center, M7, l121, o6, w210, h211, a2, e2,  12, "Courier"; ;	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic, B65535, a2, e2,  9, "Geneva"; ;	fontset = header, inactive, noKeepOnOnePage, preserveAspect, right, M7, a2, e2,  9, "Helvetica"; ;	fontset = leftheader, inactive, L2, a2, e2,  9, "Helvetica"; ;	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, right, M7, a2, e2,  9, "Helvetica"; ;	fontset = leftfooter, inactive, L2, a2, e2,  9, "Helvetica"; ;	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; ;	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; ;]:[font = title; inactive; noPageBreak; dontPreserveAspect; ]Regression Analysis;[s]1:0,1;20,-1;2:0,41,30,Times,1,40,0,0,0;1,15,11,Helvetica,1,14,0,0,0;:[font = smalltext; inactive; noPageBreak; dontPreserveAspect; center; ]1994  Rafael Richards;[s]1:0,1;22,-1;2:0,12,9,Times,0,10,0,0,0;1,7,5,Times,0,6,0,0,0;:[font = subsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Code:[font = subsubsection; inactive; Cclosed; noPageBreak; dontPreserveAspect; startGroup; ]Data Input:[font = input; noPageBreak; preserveAspect; startGroup; ](* Put relevant data and package files in path *)$Path = Join[$Path, {"RAFAEL:Apps:Mathematica:Packages:Statistics "}];$Path = Join[$Path, {"RAFAEL:SEP:data"}];numCols 	= 25;inputformat = Table[ Number, {numCols}];filename	= "albert.txt";data 		= ReadList[filename,inputformat];col = Transpose[data];v[n_]:= col[[n]]numRows = Length[data];casenum = Range[ numRows];numPoints = numRows*numCols;dataInfo  := Block[ { },   Print["File analyzed :           ", filename ];   Print["Rows in raw data:         ", numRows ];   Print["Columns in raw data:      ", numCols  ];   Print["Total data points:        ", numPoints  ]];dataInfo:[font = print; inactive; preserveAspect; endGroup; endGroup; ]File analyzed :           albert.txtRows in raw data:         673Columns in raw data:      25Total data points:        16825:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Variable Names:[font = input; noPageBreak; preserveAspect; startGroup; ](* To ask the system which variable one is operating on, define	the list of variables *)	vars = {	PtNo, 	Dtime, Ntemp, Rtemp,				Incis, IMA, Stern, CPB, Cool,				erbL,	p10L,	n13L,	n18L,	n20L,			erbR,	p10R,	n13R,	n18R,	n20R,			p22L,   ampL,   p22R, AmpR,				NtempR, Event			};var[n_]:= vars[[n]](* check lengths are equal *)TrueQ[Length[vars] == numCols]:[font = output; output; inactive; noPageBreak; preserveAspect; endGroup; endGroup; ]True;[o]True:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Range Selection:[font = input; noPageBreak; preserveAspect; endGroup; ]selAll = Table[True, {numRows}];selNone= Table[False, {numRows}];(* Initially set selection to all cases *)sel = selAll;SelectYRange[n_, ymin_, ymax_]:= 	Do[ If[ 				N[ v[n][[i]] ] <=  ymin  ||  N[ v[n][[i]] ] >=  ymax, Null, 						sel[[i]] = False],	{i,1,numRows}	];(* Selects cases of variable[n] that falls in min/max range *)SelectNonZero[n_]:= 			Do[ If[   	v[n][[i]]  != 0., Null,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are zero *)	SelectNonMissing[n_]:= 			Do[ If[  v[n][[i]] <= -500. || v[n][[i]] >= 500., 										sel[[i]] = False, Null],				{i,1, numRows}			  ]	(* OMITS cases of variable[n] that are missing data *)	SelectMissing[n_]:= 			Do[ If[  v[n][[i]] <= -500. || v[n][[i]] >= 500., 										Null, sel[[i]] = False ],				{i,1, numRows}			  ]	(* CHOSES cases of variable[n] that are missing data *)	SelectON[n_]:= 			Do[ If[   v[n][[i]]  == 1., Null ,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 1 *)	SelectOFF[n_]:= 			Do[ If[   	v[n][[i]]  == 1., sel[[i]] = False, Null],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 0 *)SelectPtNo[k_]:= Do[If[ v[1][[i]] == k,  , sel[[i]] = False ],					{i,1,numRows}					]	(* Selects cases for patient[k] *)SelectTime[tmin_,tmax_]:=		Do[ If[ 				N[ v[2][[i]] ] >=  tmin  &&  N[ v[2][[i]] ] <=  tmax,  , 						sel[[i]] = False],	{i,1,numRows}	];	(* If Dtime = v[2], select decimal time range *)	:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Case Number Range Selecton:[font = text; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]1-D and 2-D syntax:[font = input; noPageBreak; preserveAspect; endGroup; ](* Pattern matching for data input structure: ------ For 1-dimenstional list ------fun[data, {xmin, xmax, dx}] fun[list:{_?NumberQ...}, {xmin_?NumberQ, xmax_?NumberQ, dx_:1}] :=------- For 2-dimensional list ------fun[{{x1,y1}, {x2,y2}, ...}, {xmin, xmax, dx}, {ymin, ymax, dy}]fun[list:{{_?NumberQ...}...}, 		bins:{_?NumberQ, _?NumberQ, Optional[_, 1]}..] := *):[font = input; noPageBreak; preserveAspect; startGroup; ](* Selecting cases manually overrides all other selections *)(* ----- 1-dimensional list ----- *)SelectCases[{min_?NumberQ, max_?NumberQ}]:= Module[{},		sel = selNone;		Do[ If[		casenum[[i]] >= min  &&  casenum[[i]] <= max,											sel[[i]] = True, Null ],		{i,1,numRows}		];	]	(* ----- 2-dimensional list ----- *)SelectCases[list:{{_?NumberQ,_?NumberQ}...}]:= Module[{},	sel = selNone;	Do[		Do[ If[		casenum[[i]] >= list[[j,1]]  &&  casenum[[i]] <= list[[j,2]],											sel[[i]] = True, Null],		{i,1,numRows}		],		{j,1,Length[list]}	]]:[font = message; inactive; preserveAspect; endGroup; endGroup; ]General::spell1: Possible spelling error: new symbol name "list"     is similar to existing symbol "List".:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Boolean Selection:[font = text; inactive; noPageBreak; preserveAspect; ]Make the list of data pairs { sel[i], list[i] } by transposing the two vectors sel and list.				Transpose[{sel, list}]	Select[list, crit] picks out all elements ei of list for which crit[ei] is True.				Select[ {sel[i],list[i]}, First] applies First to the data pair {sel[i],list[i]}											First[{sel,lis}]			This evaluates to either True or False.			The pair {sel,lis} is picked based on this evaluation.	Map[f, expr] or f /@ expr applies f to each element on the first level in expr.					Map[Last, {sel[i],list[i]}]			 takes the last (second) element of the picked pair {s,l}.;[s]3:0,1;1,2;592,0;594,-1;3:1,13,9,Times,0,12,0,0,0;1,12,9,Courier,0,10,0,0,0;1,11,8,Courier,0,9,0,0,0;:[font = input; noPageBreak; preserveAspect; endGroup; ]BoolSelect[list_List, sel_List] := 	Map[Last, Select[Transpose[{sel, list}], First]] /; 					Length[list] == Length[sel];:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]FitStats:[font = text; inactive; Cclosed; preserveAspect; startGroup; ]other code:[font = input; preserveAspect; endGroup; ]	(*	Print[	Ndat,"\t",b,"\t \t",xxSS,"\t",xySS,"\t\t",yySS,"\t\t",resSS,						"\t",resDF,"\t \t",rSqr];	columnLabels=StringJoin[	"n","\t","b","\t \t \t","xxSS","\t\t","xySS","\t\t\t","yySS","\t\t\t","resSS",						"\t","resDF","\t", "rSqr"];	*):[font = input; noPageBreak; preserveAspect; endGroup; ]FitStats[dat_List]:=Module[{},	vMean[list_List] := Apply[Plus, list] / Length[list];	vSum[list_List]:=Apply[Plus, list];	Tdat = Transpose[dat];	Xdat = Tdat[[1]];	Ydat = Tdat[[2]];	Ndat = Length[Xdat];	totDF = Ndat -1;	regDF = 1;	resDF = Ndat - 2;		Xsum = Xdat //vSum;	Ysum = Ydat //vSum;		XYsum = Xdat Ydat //vSum;	YYsum = Ydat Ydat //vSum;	XXsum = Xdat Xdat //vSum;		xySS  = XYsum - (Xsum Ysum)/Ndat;	xxSS  = XXsum - (Xsum Xsum)/Ndat;	yySS  = YYsum - (Ysum Ysum)/Ndat;		totSS = yySS;	regSS = (xySS)^2/xxSS;	resSS = totSS - regSS;		totMS = totSS/totDF;	regMS = regSS/regDF;	resMS = resSS/resDF;		b     = xySS/xxSS;		SE    = Sxy = Sqrt[resMS];	t     = b/SE;	rSqr  = regSS/totSS;		colLabel = {"n","b","SE","t","rSqr","resSS","resDF","xxSS"};	output =   {Ndat,b,  SE,  t,  rSqr,  resSS,  resDF,  xxSS};	Print[output];		(*	Sxx  = Sqrt[xxSS/totDF];	Syy  = Sqrt[yySS/totDF];		Ymean = Ysum/Ndat;	SEnorm= SE/Ymean;	*)		];:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]TempFits:[font = input; noPageBreak; preserveAspect; endGroup; endGroup; ]TempFits[m_]:=Module[{n,p,k,selK,selC,selW,v1sel,v2sel,					lindat,logdat,					tempC, latC,datC,tempW,latW,datW},				(* W=warm; C=cool *)		k = 8;	(* variable: CPB *)		p = 9;	(* variable: COOLING *)		n = 3;	(* variable: Ntemp *)		sel = selAll;		SelectNonMissing[m];		SelectNonMissing[n];		selK = sel;				v1sel = BoolSelect[v[n],selK];		v2sel = BoolSelect[v[m],selK];		lindat = Transpose[{v1sel,v2sel}];		logdat = Transpose[{v1sel+273,Log[v2sel]}];				sel = selK;		SelectON[9]		(* Cooling ON *)		selC = sel;		(* casesC = BoolSelect[casenum,selC] //Length; *)		tempC= BoolSelect[v[n],selC];		latC = BoolSelect[v[m],selC];		datC = Transpose[{tempC,latC}];		sel = selK;		SelectON[8];	(* CPB ON *)		SelectOFF[9]	(* Cooling OFF *)		selW = sel;		(* casesW=BoolSelect[casenum,selW]//Length; *)		tempW= BoolSelect[v[n],selW];		latW = BoolSelect[v[m],selW];		datW = Transpose[{tempW,latW}];				FitStats[lindat] ;		FitStats[datC]   ;		FitStats[datW]   ;	]		:[font = subsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Function Summary:[font = input; noPageBreak; preserveAspect; endGroup; ]sel = selAll,selNone		(* resets selection vector of all cases *)n,m							(* variable(column) index numbers		*)				v[n]						(* data vector of variable n 			*)vars						(* prints out list of variables 		*)SelectYRange[n, ymin, ymax]	(* selects var[n] in range min to max 	*)SelectNonZero[n]			(* selects var[n] non-zero				*)SelectNonMissing[n]			(* selects var[n] NOT-missing 			*)SelectMissing[n]			(* selects var[n] missing 			*)SelectOFF[n]				(* selects var[n] = 0	   				*)SelectON[n]					(* selects var[n] = 1	   				*)SelectTime[tmin,tmax]		(* selects decimal time range 			*)SelectPtNo[k]				(* selects patient number k 			*)SelectCases[{min,max}]			(* select case[min] to case[max]	*)SelectCases[{{mini,maxi},..}]	(* select multiple ranges of cases 	*)BoolSelect[v[n], sel]		(* selects v[n] based on selection vector *):[font = input; noPageBreak; preserveAspect; startGroup; ]columnLabels:[font = output; output; inactive; noPageBreak; preserveAspect; endGroup; ]"n\tb\t \t \t \txxSS\t\txySS\t\t yySS\t\tresSS\tresDF\trSqr";[o]n	b	 	 	 	xxSS		xySS		 yySS		resSS	resDF	rSqr:[font = input; noPageBreak; preserveAspect; startGroup; ]var[12]			(* erb *)TempFits[12]:[font = output; output; inactive; noPageBreak; preserveAspect; ]erbL;[o]erbL:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]647	-0.424064	 	11193.3	-4746.66		3638.24		1625.35	645	 	0.55326460	-0.40807	 	2187.02	-892.457		1412.12		1047.93	458	 	0.2579187	-0.598643	 	3048.2	-1824.78		1534.86		442.465	185	 	0.711723:[font = input; noPageBreak; preserveAspect; startGroup; ]var[19]TempFits[19]:[font = output; output; inactive; noPageBreak; preserveAspect; ]erbR;[o]erbR:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]636	-0.414665	 	11137.	-4618.11		3171.		1256.03	634	 	0.6039450	-0.378867	 	2140.71	-811.044		1048.94		741.662	448	 	0.292941186	-0.557382	 	3018.88	-1682.67		1367.04		429.149	184	 	0.686074:[font = input; noPageBreak; preserveAspect; startGroup; ]var[14]			(* n13 *)TempFits[14]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n13L;[o]n13L:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]643	-0.752033	 	11129.4	-8369.67		9574.14		3279.87	641	 	0.657424458	-0.531178	 	2202.63	-1169.99		1715.84		1094.37	456	 	0.362196185	-1.06133	 	3076.55	-3265.24		5212.26		1746.77	183	 	0.664872:[font = input; noPageBreak; preserveAspect; startGroup; ]var[20]TempFits[20]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n13R;[o]n13R:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]655	-0.698149	 	11005.5	-7683.46		7595.93		2231.73	653	 	0.706194471	-0.495903	 	2331.09	-1155.99		1346.03		772.767	469	 	0.425891184	-0.926978	 	2926.62	-2712.91		3718.33		1203.53	182	 	0.676326:[font = input; noPageBreak; preserveAspect; startGroup; ]var[15]			(* n18 *)TempFits[15]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n18L;[o]n18L:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]630	-0.865019	 	10282.4	-8894.52		10468.2		2774.31	628	 	0.734978454	-0.654159	 	2203.37	-1441.36		2096.77		1153.89	452	 	0.449681176	-1.13512	 	2774.6	-3149.5			4879.81		1304.74	174	 	0.732625:[font = input; noPageBreak; preserveAspect; startGroup; ]var[20]TempFits[21]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n13R;[o]n13R:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]630	-0.867331	 	9788.57	-8489.93		9539.23		2175.65	628	 	0.771926461	-0.622154	 	2221.17	-1381.91		1593.88		734.116	459	 	0.539416169	-1.1143		 	2637.8	-2939.29		4420.06		1144.81	167	 	0.740996:[font = input; noPageBreak; preserveAspect; startGroup; ]var[16]			(* n20 *)TempFits[16]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n20L;[o]n20L:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]653	-1.04796	 	10288.4	-10781.9		14553.6		3254.62	651	 	0.77637471	-0.823878	 	2219.09	-1828.26		2952.16		1445.9	469	 	0.510224182	-1.30974	 	2680.25	-3510.44		6103.65		1505.87	180	 	0.753284:[font = input; noPageBreak; preserveAspect; startGroup; ]var[22]TempFits[22]:[font = output; output; inactive; noPageBreak; preserveAspect; ]n20R;[o]n20R:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]657	-1.00103	 	10184.3	-10194.7		12943.6		2738.35	655	 	0.788439477	-0.795123		2337.77	-1858.81		2766.56		1288.57	475	 	0.534232180	-1.19328		2550.16	-3043.06		4887.62		1256.39	178	 	0.742945:[font = input; noPageBreak; preserveAspect; startGroup; ]var[17]			(* p22 *)TempFits[17]:[font = output; output; inactive; noPageBreak; preserveAspect; ]p22L;[o]p22L:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]652	-1.27858	 	10219.7	-13066.7		22018.8		5311.95	650	 	0.758754471	-0.983658	 	2219.1	-2182.83		4292.08		2144.92	469	 	0.500261181	-1.60467	 	2666.61	-4279.03		9548.21		2681.78	179	 	0.719133:[font = input; noPageBreak; preserveAspect; startGroup; ]var[23]TempFits[23]:[font = output; output; inactive; noPageBreak; preserveAspect; ]p22R;[o]p22R:[font = print; inactive; noPageBreak; preserveAspect; endGroup; ]650	-1.2106	 		10074.4	-12196.1		18853.3		4088.62	648	 	0.783134471	-0.939067	 	2331.58	-2189.51		4056.		1999.91	469	 	0.506927179	-1.38726	 	2536.53	-3518.83		6712.59		1831.07	177	 	0.727218:[font = subsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Unused:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]reference:[font = text; inactive; noPageBreak; preserveAspect; startGroup; ]Statistics:[font = text; inactive; noPageBreak; preserveAspect; ]You can often avoid using loops in Mathematica  by operating directly on complete lists. The resulting programs are usually more elegant and more efficient. Here are programs for computing the mean, variance, and quantiles of a list.;[s]3:0,0;35,1;48,0;234,-1;2:2,13,9,Times,0,12,0,0,0;1,13,9,Times,2,12,0,0,0;:[font = input; noPageBreak; preserveAspect; ]Mean[list_List] := Apply[Plus, list] / Length[list]:[font = input; noPageBreak; preserveAspect; ]Variance[list_List] := Mean[ (list - Mean[list])^2 ]:[font = input; noPageBreak; preserveAspect; endGroup; endGroup; ]Quantile[list_List, q_] :=          Part[ Sort[list],              -Floor[-q Length[list]] ] /; 0 < q < 1:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]External Packages:[font = input; noPageBreak; preserveAspect; startGroup; ]<<RAFAEL:Mathematica:Packages:Statistics:NonlinearFit.m:[font = input; noPageBreak; preserveAspect; ]<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m:[font = input; noPageBreak; preserveAspect; endGroup; ]<<RAFAEL:Mathematica:Packages:Statistics:MovingAverage.m:[font = input; Cclosed; noPageBreak; preserveAspect; startGroup; ]?MovingAverage:[font = info; inactive; noPageBreak; preserveAspect; endGroup; ]MovingAverage[list,n] returns a list of the n-th moving averages of   list.:[font = input; Cclosed; noPageBreak; preserveAspect; startGroup; ]?NonlinearFit:[font = info; inactive; noPageBreak; preserveAspect; endGroup; ]NonlinearFit[data,model,vars,params,(opts)] uses iterative methods   to fit the data to the model containing the given variables and   parameters.  Paramaters may be expressed as a list of symbols   or {symbol, startingvalue} pairs.  The data are given as {{x1,   y1, ..., f1},{x2, y2, ... f2},...}; some variations on this are   also valid (see documentation.):[font = input; noPageBreak; preserveAspect; ]<<RAFAEL:Mathematica:Packages:NumericalMath:PolynomialFit.m(* <<RAFAEL:Mathematica:Packages:NumericalMath:SplineFit.m  *):[font = input; noPageBreak; preserveAspect; endGroup; ]<<RAFAEL:Mathematica:Packages:Graphics:Spline.m:[font = subsubsection; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Regression:[font = text; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]Fit[  ]:[font = input; noPageBreak; preserveAspect; endGroup; ](* built-in Fit[] function 10x faster than Regress[] package *)linfit[n_,m_]:=Module[{v1sel,v2sel,datsel,line},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				line = Fit[ Transpose[{v1sel,v2sel}],{1,x},x]		]		linA[n_,m_]:= linfit[v[n],v[m]] [[1]];linB[n_,m_]:= linfit[v[n],v[m]] [[2,1]];:[font = text; inactive; Cclosed; noPageBreak; preserveAspect; startGroup; ]LinearRegression.m:[font = input; noPageBreak; preserveAspect; startGroup; ](* load external package for regression parameters *)<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m  :[font = input; noPageBreak; preserveAspect; startGroup; ]??Regress:[font = info; inactive; noPageBreak; preserveAspect; endGroup; ]Regress[data, funs, vars] finds a least-squares fit to a list of data as a   linear combination of the functions funs of variables vars. The data can   have the form {{x1, y1, ..., f1}, {x2, y2, ..., f2}, ...}, where the   number of coordinates x, y, ... is equal to the number of variables in   the list vars.  The data can also be of the form {f1, f2, ...}, with a   single coordinate assumed to take values 1, 2, .... The argument funs can   be any list of functions that depend only on the objects vars.Attributes[Regress] = {Protected, ReadProtected}:[font = input; noPageBreak; preserveAspect; startGroup; ]Options[Regress]  :[font = output; output; inactive; noPageBreak; preserveAspect; endGroup; endGroup; ]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,   BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,   ConfidenceLevel -> 0.95};[o]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,    BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,    ConfidenceLevel -> 0.95}:[font = input; noPageBreak; preserveAspect; endGroup; endGroup; endGroup; ]linR2[n_,m_]:= Module[{v1sel,v2sel,datsel,reg },		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];			reg = Regress[datsel,{1,x},x,		OutputControl-> NoPrint,		OutputList->{RSquared} 	(*BestFitCoefficients,BestFit *)		];				(* {a,b}=BestFitCoefficients /. reg[[1]]  *)		RSquared /. reg[[1]]	]	RSqr[dat_]:= Module[{reg},				reg = Regress[ dat, {1,x},x,					OutputControl ->NoPrint,					OutputList ->{RSquared}					];				RSquared /. reg[[1]]				]:[font = input; preserveAspect; ]<<ConfidenceIntervals.m:[font = input; preserveAspect; startGroup; ]?StudentTCI:[font = info; inactive; preserveAspect; endGroup; ]StudentTCI[mean, se, dof, ConfidenceLevel -> c] returns a list {min,   max} representing a confidence interval at  confidence level c for   the population mean, based on a sample mean, its standard error se   and dof degrees of freedom. This function is used by MeanCI when the   population variance is estimated from the sample.:[font = input; preserveAspect; startGroup; ]?StudentTDistribution:[font = info; inactive; preserveAspect; endGroup; ]StudentTDistribution[n] represents Student's T distribution with n   degrees of freedom.:[font = input; preserveAspect; startGroup; ]?StudentTDistribution:[font = info; inactive; preserveAspect; endGroup; ]StudentTDistribution[n] represents Student's T distribution with n   degrees of freedom.:[font = input; preserveAspect; startGroup; ]StudentTDistribution:[font = output; output; inactive; preserveAspect; endGroup; ]StudentTDistribution;[o]StudentTDistribution:[font = input; preserveAspect; ]<<ContinuousDistributions.m:[font = input; preserveAspect; startGroup; ]?NoncentralStudentTDistribution:[font = info; inactive; preserveAspect; endGroup; ]NoncentralStudentTDistribution[n, delta] represents the non-central   Student's t distribution with n degrees of freedom and non-centrality   parameter delta.:[font = input; preserveAspect; ]<<HypothesisTests.m:[font = input; preserveAspect; startGroup; ]?*StudentT*:[font = info; inactive; preserveAspect; endGroup; ]NoncentralStudentTDistribution StudentTDistributionStudentTCI                     StudentTPValue:[font = input; preserveAspect; startGroup; ]?StudentTPValue:[font = info; inactive; preserveAspect; endGroup; ]StudentTPValue[teststat, dof] returns the cumulative density beyond   teststat for the StudentTDistribution, with dof degrees of freedom.^*)