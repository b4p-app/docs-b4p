(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.2";	MacintoshStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, a2, e2,  18, "Helvetica"; 	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, a2, e2,  12, "Helvetica"; 	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic, a2, e2,  9, "Helvetica"; 	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, a2, e2,  14, "Helvetica"; 	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, a2, e2,  12, "Helvetica"; 	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, a2, e2,  10, "Helvetica"; 	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; 	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-5, a1, e2,  9, "Courier"; 	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a1, e2,  9, "Courier"; 	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R65535, L-5, a1, e2,  9, "Courier"; 	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a1, e2,  9, "Courier"; 	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B65535, L-5, a1, e2,  9, "Courier"; 	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, l80, w252, h252, a2, e2,  12, "Courier"; 	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic, B65535, a2, e2,  10, "Arial MT Condensed Light"; 	fontset = header, inactive, noKeepOnOnePage, preserveAspect, M7, a2, e2,  9, "Helvetica"; 	fontset = leftheader, inactive, L2, a2, e2,  9, "Helvetica"; 	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, center, M7, a2, e2,  9, "Helvetica"; 	fontset = leftfooter, inactive, L2, a2, e2,  9, "Helvetica"; 	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; 	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; 	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  9, "Courier"; 	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	paletteColors = 128; ]:[font = title; inactive; preserveAspect]Regression Analysis:[font = smalltext; inactive; preserveAspect]1995 RM Richards :[font = subsubsection; inactive; preserveAspect; startGroup]Code:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Data Input:[font = input; Cclosed; preserveAspect; startGroup](* Put relevant data and package files in path *)$Path = Join[$Path, {"RAFAEL:Apps:Mathematica:Packages:Statistics "}];$Path = Join[$Path, {"RAFAEL:SEP:data"}];numCols 	= 25;inputformat = Table[ Number, {numCols}];filename	= "albert.txt";data 		= ReadList[filename,inputformat];col = Transpose[data];v[n_]:= col[[n]]numRows = Length[data];casenum = Range[ numRows];numPoints = numRows*numCols;dataInfo  := Block[ { },   Print["File analyzed :           ", filename ];   Print["Rows in raw data:         ", numRows ];   Print["Columns in raw data:      ", numCols  ];   Print["Total data points:        ", numPoints  ]];dataInfo:[font = message; inactive; preserveAspect]General::spell1:    Possible spelling error: new symbol name "data"     is similar to existing symbol "dat".:[font = print; inactive; preserveAspect; endGroup; endGroup]File analyzed :           albert.txtRows in raw data:         673Columns in raw data:      25Total data points:        16825:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Variable Names:[font = input; Cclosed; preserveAspect; startGroup](* To ask the system which variable one is operating on, define	the list of variables *)	vars = {	PtNo, 	Dtime, Ntemp, Rtemp,				Incis, IMA, Stern, CPB, Cool,				erbL,	p10L,	n13L,	n18L,	n20L,			erbR,	p10R,	n13R,	n18R,	n20R,			p22L,   ampL,   p22R, AmpR,				NtempR, Event			};var[n_]:= vars[[n]](* check lengths are equal *)TrueQ[Length[vars] == numCols]:[font = message; inactive; preserveAspect]General::spell1:    Possible spelling error: new symbol name "Rtemp"     is similar to existing symbol "Ntemp".:[font = message; inactive; preserveAspect]General::spell1:    Possible spelling error: new symbol name "erbR"     is similar to existing symbol "erbL".:[font = message; inactive; preserveAspect]General::spell1:    Possible spelling error: new symbol name "p10R"     is similar to existing symbol "p10L".:[font = message; inactive; preserveAspect]General::stop: Further output of General::spell1     will be suppressed during this calculation.:[font = output; output; inactive; preserveAspect; endGroup; endGroup]True;[o]True:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Range Selection:[font = input; preserveAspect; endGroup]selAll = Table[True, {numRows}];selNone= Table[False, {numRows}];(* Initially set selection to all cases *)sel = selAll;SelectYRange[n_, ymin_, ymax_]:= 	Do[ If[ 				N[ v[n][[i]] ] <=  ymin  ||  N[ v[n][[i]] ] >=  ymax, Null, 						sel[[i]] = False],	{i,1,numRows}	];(* Selects cases of variable[n] that falls in min/max range *)SelectNonZero[n_]:= 			Do[ If[   	v[n][[i]]  != 0., Null,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are zero *)	SelectNonMissing[n_]:= 			Do[ If[  v[n][[i]] <= -500. || v[n][[i]] >= 500., 										sel[[i]] = False, Null],				{i,1, numRows}			  ]	(* OMITS cases of variable[n] that are missing data *)	SelectMissing[n_]:= 			Do[ If[  v[n][[i]] <= -500. || v[n][[i]] >= 500., 										Null, sel[[i]] = False ],				{i,1, numRows}			  ]	(* CHOSES cases of variable[n] that are missing data *)	SelectON[n_]:= 			Do[ If[   v[n][[i]]  == 1., Null ,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 1 *)	SelectOFF[n_]:= 			Do[ If[   	v[n][[i]]  == 1., sel[[i]] = False, Null],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 0 *)SelectPtNo[k_]:= Do[If[ v[1][[i]] == k,  , sel[[i]] = False ],					{i,1,numRows}					]	(* Selects cases for patient[k] *)SelectTime[tmin_,tmax_]:=		Do[ If[ 				N[ v[2][[i]] ] >=  tmin  &&  N[ v[2][[i]] ] <=  tmax,  , 						sel[[i]] = False],	{i,1,numRows}	];	(* If Dtime = v[2], select decimal time range *)	:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Case Number Range Selecton:[font = text; inactive; Cclosed; preserveAspect; startGroup]1-D and 2-D syntax:[font = input; preserveAspect; endGroup](* Pattern matching for data input structure: ------ For 1-dimenstional list ------fun[data, {xmin, xmax, dx}] fun[list:{_?NumberQ...}, {xmin_?NumberQ, xmax_?NumberQ, dx_:1}] :=------- For 2-dimensional list ------fun[{{x1,y1}, {x2,y2}, ...}, {xmin, xmax, dx}, {ymin, ymax, dy}]fun[list:{{_?NumberQ...}...}, 		bins:{_?NumberQ, _?NumberQ, Optional[_, 1]}..] := *):[font = input; preserveAspect; endGroup](* Selecting cases manually overrides all other selections *)(* ----- 1-dimensional list ----- *)SelectCases[{min_?NumberQ, max_?NumberQ}]:= Module[{},		sel = selNone;		Do[ If[		casenum[[i]] >= min  &&  casenum[[i]] <= max,											sel[[i]] = True, Null ],		{i,1,numRows}		];	]	(* ----- 2-dimensional list ----- *)SelectCases[list:{{_?NumberQ,_?NumberQ}...}]:= Module[{},	sel = selNone;	Do[		Do[ If[		casenum[[i]] >= list[[j,1]]  &&  casenum[[i]] <= list[[j,2]],											sel[[i]] = True, Null],		{i,1,numRows}		],		{j,1,Length[list]}	]]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Boolean Selection:[font = text; inactive; preserveAspect]Make the list of data pairs { sel[i], list[i] } by transposing the two vectors sel and list.				Transpose[{sel, list}]	Select[list, crit] picks out all elements ei of list for which crit[ei] is True.				Select[ {sel[i],list[i]}, First] applies First to the data pair {sel[i],list[i]}											First[{sel,lis}]			This evaluates to either True or False.			The pair {sel,lis} is picked based on this evaluation.	Map[f, expr] or f /@ expr applies f to each element on the first level in expr.					Map[Last, {sel[i],list[i]}]			 takes the last (second) element of the picked pair {s,l}.:[font = input; preserveAspect; endGroup]BoolSelect[list_List, sel_List] := 	Map[Last, Select[Transpose[{sel, list}], First]] /; 					Length[list] == Length[sel];:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Function Summary:[font = input; Cclosed; preserveAspect; startGroup]sel = selAll,selNone		(* resets selection vector of all cases *)n,m							(* variable(column) index numbers		*)				v[n]						(* data vector of variable n 			*)vars						(* prints out list of variables 		*)SelectYRange[n, ymin, ymax]	(* selects var[n] in range min to max 	*)SelectNonZero[n]			(* selects var[n] non-zero				*)SelectNonMissing[n]			(* selects var[n] NOT-missing 			*)SelectMissing[n]			(* selects var[n] missing 			*)SelectOFF[n]				(* selects var[n] = 0	   				*)SelectON[n]					(* selects var[n] = 1	   				*)SelectTime[tmin,tmax]		(* selects decimal time range 			*)SelectPtNo[k]				(* selects patient number k 			*)SelectCases[{min,max}]			(* select case[min] to case[max]	*)SelectCases[{{mini,maxi},..}]	(* select multiple ranges of cases 	*)BoolSelect[v[n], sel]		(* selects v[n] based on selection vector *):[font = message; inactive; preserveAspect; endGroup; endGroup]Syntax::sntxf: "sel = selAll" cannot be followed by     ",selNone		                                          ".:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]FitStats:[font = text; inactive; Cclosed; preserveAspect; startGroup]other code:[font = input; preserveAspect; endGroup]	(*	Print[	Ndat,"\t",b,"\t \t",xxSS,"\t",xySS,"\t\t",yySS,"\t\t",resSS,						"\t",resDF,"\t \t",rSqr];	columnLabels=StringJoin[	"n","\t","b","\t \t \t","xxSS","\t\t","xySS","\t\t\t","yySS","\t\t\t","resSS",						"\t","resDF","\t", "rSqr"];	*):[font = input; preserveAspect; endGroup]FitStats[dat_List]:=Module[{},	vMean[list_List] := Apply[Plus, list] / Length[list];	vSum[list_List]:=Apply[Plus, list];	Tdat = Transpose[dat];	Xdat = Tdat[[1]];	Ydat = Tdat[[2]];	Ndat = Length[Xdat];	totDF = Ndat -1;	regDF = 1;	resDF = Ndat - 2;		Xsum = Xdat //vSum;	Ysum = Ydat //vSum;		XYsum = Xdat Ydat //vSum;	YYsum = Ydat Ydat //vSum;	XXsum = Xdat Xdat //vSum;		xySS  = XYsum - (Xsum Ysum)/Ndat;	xxSS  = XXsum - (Xsum Xsum)/Ndat;	yySS  = YYsum - (Ysum Ysum)/Ndat;		totSS = yySS;	regSS = (xySS)^2/xxSS;	resSS = totSS - regSS;		totMS = totSS/totDF;	regMS = regSS/regDF;	resMS = resSS/resDF;	Sxy = Sqrt[resMS];		b     = xySS/xxSS;			(* slope *)	Sb	  = Sqrt[Sxy^2/xxSS];	(* SE: std error of estimate (of slope) *)	t     = b/Sb;	rSqr  = regSS/totSS;		(* coeff of determination *)			colLabel = {"n","b","Sb","t","rSqr","resSS","resDF","xxSS"};	output =   {Ndat,b,  Sb,  t,  rSqr,  resSS,  resDF,  xxSS}		(*	Print[output];		Sxx  = Sqrt[xxSS/totDF];	Syy  = Sqrt[yySS/totDF];		Ymean = Ysum/Ndat;	SEnorm= SE/Ymean;	*)		];:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]T-Test for comparing two slopes:[font = input; preserveAspect; endGroup]Ttest[A_List,B_List]:=Module[{b1,b2,resSS1,resSS2,							resDF1,resDF2,Syxp,Sb1b2,t,mu,output},			b1 = A[[2]];			b2 = B[[2]];			resSS1= A[[6]];			resSS2= B[[6]];			resDF1= A[[7]];			resDF2= B[[7]];			xxSS1 = A[[8]];			xxSS2 = B[[8]];						Syxp = (resSS1 + resSS2)/(resDF1 + resDF2);			Sb1b2= Sqrt[ Syxp/xxSS1 + Syxp/xxSS2  ];			t = (b1 - b2)/Sb1b2;			mu = resDF1 + resDF2;						output = {t,mu}			];:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]TempFits:[font = input; preserveAspect; endGroup; endGroup]TempFits[m_]:=Module[{n,p,k,selK,selC,selW,v1sel,v2sel,					lindat,logdat,					tempC, latC,datC,tempW,latW,datW},				(* W=warm; C=cool *)		k = 8;	(* variable: CPB *)		p = 9;	(* variable: COOLING *)		n = 3;	(* variable: Ntemp *)		sel = selAll;		SelectNonMissing[m];		SelectNonMissing[n];		selK = sel;				v1sel = BoolSelect[v[n],selK];		v2sel = BoolSelect[v[m],selK];		lindat = Transpose[{v1sel,v2sel}];		logdat = Transpose[{1/(v1sel+273),Log[v2sel]}];				logfit = Fit[logdat,{1,1/x},x] /. x -> x+273;								sel = selK;		SelectON[p];		(* Cooling ON *)		(* casesC = BoolSelect[casenum,selC] //Length; *)		tempC= BoolSelect[v[n],sel];		latC = BoolSelect[v[m],sel];		datC = Transpose[{tempC,latC}];		sel = selK;		SelectON[k];	(* CPB ON *)		SelectOFF[p];	(* Cooling OFF *)		(* casesW=BoolSelect[casenum,selW]//Length; *)		tempW= BoolSelect[v[n],sel];		latW = BoolSelect[v[m],sel];		datW = Transpose[{tempW,latW}];				Arr=FitStats[logdat] ;		Lin=FitStats[lindat] ;		Cool=FitStats[datC]   ;		Warm=FitStats[datW]   ;				Print["Arr= ",Arr];		Print["Lin= ",Lin];		Print["Cool= ",Cool];		Print["Warm= ",Warm];				Print["\t \t \t","t","\t \t","mu"];		Print["Arr-Lin:   ", Ttest[Arr,Lin]  ];		Print["Lin-Cool:  ", Ttest[Lin,Cool]  ];		Print["Lin-Warm:  ", Ttest[Lin,Warm] ];		Print["Cool-Warm: ", Ttest[Cool,Warm] ];	]		:[font = input; preserveAspect; startGroup]colLabel:[font = output; output; inactive; preserveAspect; endGroup]{"n", "b", "Sb", "t", "rSqr", "resSS", "resDF", "xxSS"};[o]{n, b, Sb, t, rSqr, resSS, resDF, xxSS}:[font = input; preserveAspect; startGroup]var[10]			(* erb *)TempFits[10]:[font = output; output; inactive; preserveAspect]erbL;[o]erbL:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {647, 2783.6, 106.323, 26.1806, 0.515191, 9.58873, 645, 1.31506 10  }Lin= {647, -0.424064, 0.0150043, -28.2629, 0.55326, 1625.35, 645, 11193.3}Cool= {187, -0.598643, 0.0280112, -21.3716, 0.711723, 442.465, 185, 3048.2}Warm= {137, -0.397047, 0.0390851, -10.1585, 0.433239, 356.699, 135, 1729.59};[o]Can't format cell.:[font = input; Cclosed; preserveAspect; startGroup]var[15]TempFits[15]:[font = output; output; inactive; preserveAspect]erbR;[o]erbR:[font = print; inactive; preserveAspect; endGroup]                                                                        -6Arr= {655, 2762.38, 96.9078, 28.5053, 0.554433, 8.12455, 653, 1.32486 10  }Lin= {655, -0.41305, 0.0131191, -31.4845, 0.602865, 1267.82, 653, 11280.7}Cool= {188, -0.55377, 0.0276324, -20.0406, 0.683473, 433.589, 186, 3053.02}Warm= {145, -0.353003, 0.0306862, -11.5037, 0.480631, 247.387, 143, 1837.19}:[font = input; preserveAspect; startGroup]var[12]			(* n13 *)TempFits[12]:[font = output; output; inactive; preserveAspect]n13L;[o]n13L:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {643, 3387.21, 91.192, 37.1437, 0.682776, 6.97109, 641, 1.30776 10  }Lin= {643, -0.752033, 0.0214419, -35.073, 0.657424, 3279.87, 641, 11129.4}Cool= {185, -1.06133, 0.0557007, -19.0541, 0.664872, 1746.77, 183, 3076.55}Warm= {136, -0.5403, 0.0408605, -13.223, 0.566131, 389.418, 134, 1740.62}:[font = input; Cclosed; preserveAspect; startGroup]var[17]TempFits[17]:[font = output; output; inactive; preserveAspect]n13R;[o]n13R:[font = print; inactive; preserveAspect; endGroup]                                                                        -6Arr= {656, 3238.27, 79.8555, 40.5516, 0.715458, 5.39047, 654, 1.29252 10  }Lin= {656, -0.697688, 0.0176198, -39.5969, 0.705659, 2235.82, 654, 11011.8}Cool= {184, -0.926978, 0.0475346, -19.5011, 0.676326, 1203.53, 182, 2926.62}Warm= {144, -0.470208, 0.030255, -15.5415, 0.629763, 237.977, 142, 1830.85}:[font = input; Cclosed; preserveAspect; startGroup]var[13]			(* n18 *)TempFits[13]:[font = output; output; inactive; preserveAspect]n18L;[o]n18L:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {630, 3298.88, 79.1516, 41.678, 0.734467, 4.74537, 628, 1.20612 10  }Lin= {630, -0.865019, 0.0207276, -41.7327, 0.734978, 2774.31, 628, 10282.4}Cool= {176, -1.13512, 0.0519861, -21.8351, 0.732625, 1304.74, 174, 2774.6}Warm= {137, -0.669068, 0.0427724, -15.6425, 0.644445, 432.182, 135, 1749.87}:[font = input; Cclosed; preserveAspect; startGroup]var[18]TempFits[18]:[font = output; output; inactive; preserveAspect]n18R;[o]n18R:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {630, 3308.36, 69.3049, 47.7364, 0.783952, 3.46102, 628, 1.1474 10  }Lin= {630, -0.867331, 0.0188129, -46.1031, 0.771926, 2175.65, 628, 9788.57}Cool= {169, -1.1143, 0.0509786, -21.8581, 0.740996, 1144.81, 167, 2637.8}Warm= {142, -0.606254, 0.032864, -18.4474, 0.708519, 273.701, 140, 1810.12}:[font = input; Cclosed; preserveAspect; startGroup]var[14]			(* n20 *)TempFits[14]:[font = output; output; inactive; preserveAspect]n20L;[o]n20L:[font = print; inactive; preserveAspect; endGroup]                                                                        -6Arr= {653, 3581.19, 75.5377, 47.4094, 0.775412, 4.47189, 651, 1.20388 10  }Lin= {653, -1.04796, 0.0220437, -47.5401, 0.77637, 3254.62, 651, 10288.4}Cool= {182, -1.30974, 0.0558688, -23.4432, 0.753284, 1505.87, 180, 2680.25}Warm= {139, -0.835349, 0.0476802, -17.5198, 0.691403, 546.81, 137, 1755.66}:[font = input; Cclosed; preserveAspect; startGroup]var[19]TempFits[19]:[font = output; output; inactive; preserveAspect]n20R;[o]n20R:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {657, 3467.18, 72.2505, 47.9884, 0.778558, 4.0706, 655, 1.19051 10  }Lin= {657, -1.00103, 0.0202609, -49.4069, 0.788439, 2738.35, 655, 10184.3}Cool= {180, -1.19328, 0.05261, -22.6817, 0.742945, 1256.39, 178, 2550.16}Warm= {147, -0.758887, 0.043172, -17.5782, 0.680612, 497.241, 145, 1839.9}:[font = input; Cclosed; preserveAspect; startGroup]var[20]			(* p22 *)TempFits[20]:[font = output; output; inactive; preserveAspect]p22L;[o]p22L:[font = print; inactive; preserveAspect; endGroup]                                                                        -6Arr= {652, 3720.56, 80.4856, 46.2264, 0.766764, 5.03505, 650, 1.19579 10  }Lin= {652, -1.27858, 0.0282781, -45.2144, 0.758754, 5311.95, 650, 10219.7}Cool= {181, -1.60467, 0.0749558, -21.4082, 0.719133, 2681.78, 179, 2666.61}Warm= {138, -0.981392, 0.0532323, -18.436, 0.714218, 676.261, 136, 1754.79}:[font = input; Cclosed; preserveAspect; startGroup]var[22]TempFits[22]:[font = output; output; inactive; preserveAspect]p22R;[o]p22R:[font = print; inactive; preserveAspect; endGroup]                                                                       -6Arr= {650, 3611.3, 76.1264, 47.4382, 0.776427, 4.42256, 648, 1.17768 10  }Lin= {650, -1.2106, 0.025026, -48.3738, 0.783134, 4088.62, 648, 10074.4}Cool= {179, -1.38726, 0.0638625, -21.7226, 0.727218, 1831.07, 177, 2536.53}Warm= {143, -0.874386, 0.0497975, -17.5588, 0.686187, 636.355, 141, 1819.97}:[font = subsection; inactive; preserveAspect; startGroup]T-Tables:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]mu < 50:[font = postscript; PICT; formatAsPICT; output; inactive; preserveAspect; pictureLeft = 0; pictureWidth = 501; pictureHeight = 637; endGroup; pictureID = 25988]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]mu > 51:[font = postscript; PICT; formatAsPICT; output; inactive; preserveAspect; pictureLeft = 0; pictureWidth = 508; pictureHeight = 671; endGroup; endGroup; pictureID = 16794]:[font = subsection; inactive; preserveAspect; startGroup]unbenutzt:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]reference:[font = text; inactive; Cclosed; preserveAspect; startGroup]Statistics:[font = text; inactive; preserveAspect]You can often avoid using loops in Mathematica  by operating directly on complete lists. The resulting programs are usually more elegant and more efficient. Here are programs for computing the mean, variance, and quantiles of a list.:[font = input; preserveAspect]Mean[list_List] := Apply[Plus, list] / Length[list]:[font = input; preserveAspect]Variance[list_List] := Mean[ (list - Mean[list])^2 ]:[font = input; preserveAspect; endGroup; endGroup]Quantile[list_List, q_] :=          Part[ Sort[list],              -Floor[-q Length[list]] ] /; 0 < q < 1:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]External Packages:[font = input; Cclosed; preserveAspect; startGroup]<<RAFAEL:Mathematica:Packages:Statistics:NonlinearFit.m:[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m:[font = input; preserveAspect; endGroup]<<RAFAEL:Mathematica:Packages:Statistics:MovingAverage.m:[font = input; Cclosed; preserveAspect; startGroup]?MovingAverage:[font = info; inactive; preserveAspect; endGroup]MovingAverage[list,n] returns a list of the n-th moving averages of   list.:[font = input; Cclosed; preserveAspect; startGroup]?NonlinearFit:[font = info; inactive; preserveAspect; endGroup]NonlinearFit[data,model,vars,params,(opts)] uses iterative methods   to fit the data to the model containing the given variables and   parameters.  Paramaters may be expressed as a list of symbols   or {symbol, startingvalue} pairs.  The data are given as {{x1,   y1, ..., f1},{x2, y2, ... f2},...}; some variations on this are   also valid (see documentation.):[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:NumericalMath:PolynomialFit.m(* <<RAFAEL:Mathematica:Packages:NumericalMath:SplineFit.m  *):[font = input; preserveAspect; endGroup]<<RAFAEL:Mathematica:Packages:Graphics:Spline.m:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Regression:[font = text; inactive; Cclosed; preserveAspect; startGroup]Fit[  ]:[font = input; preserveAspect; endGroup](* built-in Fit[] function 10x faster than Regress[] package *)linfit[n_,m_]:=Module[{v1sel,v2sel,datsel,line},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				line = Fit[ Transpose[{v1sel,v2sel}],{1,x},x]		]		linA[n_,m_]:= linfit[v[n],v[m]] [[1]];linB[n_,m_]:= linfit[v[n],v[m]] [[2,1]];:[font = text; inactive; Cclosed; preserveAspect; startGroup]LinearRegression.m:[font = input; Cclosed; preserveAspect; startGroup](* load external package for regression parameters *)<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m  :[font = input; Cclosed; preserveAspect; startGroup]??Regress:[font = info; inactive; preserveAspect; endGroup]Regress[data, funs, vars] finds a least-squares fit to a list of data as a   linear combination of the functions funs of variables vars. The data can   have the form {{x1, y1, ..., f1}, {x2, y2, ..., f2}, ...}, where the   number of coordinates x, y, ... is equal to the number of variables in   the list vars.  The data can also be of the form {f1, f2, ...}, with a   single coordinate assumed to take values 1, 2, .... The argument funs can   be any list of functions that depend only on the objects vars.Attributes[Regress] = {Protected, ReadProtected}:[font = input; Cclosed; preserveAspect; startGroup]Options[Regress]  :[font = output; output; inactive; preserveAspect; endGroup; endGroup]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,   BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,   ConfidenceLevel -> 0.95};[o]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,    BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,    ConfidenceLevel -> 0.95}:[font = input; preserveAspect; endGroup; endGroup]linR2[n_,m_]:= Module[{v1sel,v2sel,datsel,reg },		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];			reg = Regress[datsel,{1,x},x,		OutputControl-> NoPrint,		OutputList->{RSquared} 	(*BestFitCoefficients,BestFit *)		];				(* {a,b}=BestFitCoefficients /. reg[[1]]  *)		RSquared /. reg[[1]]	]	RSqr[dat_]:= Module[{reg},				reg = Regress[ dat, {1,x},x,					OutputControl ->NoPrint,					OutputList ->{RSquared}					];				RSquared /. reg[[1]]				]:[font = input; preserveAspect]<<ConfidenceIntervals.m:[font = input; Cclosed; preserveAspect; startGroup]?StudentTCI:[font = info; inactive; preserveAspect; endGroup]StudentTCI[mean, se, dof, ConfidenceLevel -> c] returns a list {min,   max} representing a confidence interval at  confidence level c for   the population mean, based on a sample mean, its standard error se   and dof degrees of freedom. This function is used by MeanCI when the   population variance is estimated from the sample.:[font = input; Cclosed; preserveAspect; startGroup]?StudentTDistribution:[font = info; inactive; preserveAspect; endGroup]StudentTDistribution[n] represents Student's T distribution with n   degrees of freedom.:[font = input; Cclosed; preserveAspect; startGroup]?StudentTDistribution:[font = info; inactive; preserveAspect; endGroup]StudentTDistribution[n] represents Student's T distribution with n   degrees of freedom.:[font = input; Cclosed; preserveAspect; startGroup]StudentTDistribution:[font = output; output; inactive; preserveAspect; endGroup]StudentTDistribution;[o]StudentTDistribution:[font = input; preserveAspect]<<ContinuousDistributions.m:[font = input; Cclosed; preserveAspect; startGroup]?NoncentralStudentTDistribution:[font = info; inactive; preserveAspect; endGroup]NoncentralStudentTDistribution[n, delta] represents the non-central   Student's t distribution with n degrees of freedom and non-centrality   parameter delta.:[font = input; preserveAspect]<<HypothesisTests.m:[font = input; Cclosed; preserveAspect; startGroup]?*StudentT*:[font = info; inactive; preserveAspect; endGroup]NoncentralStudentTDistribution StudentTDistributionStudentTCI                     StudentTPValue:[font = input; Cclosed; preserveAspect; startGroup]?StudentTPValue:[font = info; inactive; preserveAspect; endGroup; endGroup]StudentTPValue[teststat, dof] returns the cumulative density beyond   teststat for the StudentTDistribution, with dof degrees of freedom.^*)