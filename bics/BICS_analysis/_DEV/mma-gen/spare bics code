(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.2";	MacintoshStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold,  24, "Helvetica"; 	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold,  12, "Helvetica"; 	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic,  9, "Helvetica"; 	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold,  18, "Helvetica"; 	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold,  14, "Helvetica"; 	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold,  12, "Helvetica"; 	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-5,  12, "Courier"; 	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5,  12, "Courier"; 	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R65535, L-5,  12, "Courier"; 	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5,  12, "Courier"; 	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B65535, L-5,  12, "Courier"; 	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, l34, w282, h287,  12, "Courier"; 	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic,  10, "Geneva"; 	fontset = header, inactive, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = leftheader, inactive, L2,  12, "Times"; 	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, center, M7,  12, "Times"; 	fontset = leftfooter, inactive, L2,  12, "Times"; 	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	paletteColors = 128; automaticGrouping; magnification = 95; currentKernel; ]:[font = title; inactive; preserveAspect; startGroup]BICS Reference code:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]T-Test for comparing two slopes:[font = input; preserveAspect; endGroup]Ttest[A_List,B_List]:=Module[{b1,b2,resSS1,resSS2,							resDF1,resDF2,Syxp,Sb1b2,t,mu,output},			b1 = A[[2]];			b2 = B[[2]];			resSS1= A[[6]];			resSS2= B[[6]];			resDF1= A[[7]];			resDF2= B[[7]];			xxSS1 = A[[8]];			xxSS2 = B[[8]];						Syxp = (resSS1 + resSS2)/(resDF1 + resDF2);			Sb1b2= Sqrt[ Syxp/xxSS1 + Syxp/xxSS2  ];			t = (b1 - b2)/Sb1b2;			mu = resDF1 + resDF2;						output = {t,mu}			];:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]T-Tables:[font = text; inactive; preserveAspect]mu < 50:[font = postscript; PICT; formatAsPICT; output; inactive; preserveAspect; pictureLeft = 0; pictureWidth = 501; pictureHeight = 637; pictureID = 27394]:[font = text; inactive; preserveAspect]mu > 51:[font = postscript; PICT; formatAsPICT; output; inactive; preserveAspect; pictureLeft = 0; pictureWidth = 508; pictureHeight = 671; endGroup; pictureID = 21514]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]External Packages:[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:Statistics:NonlinearFit.m:[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m:[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:Statistics:MovingAverage.m:[font = input; preserveAspect; startGroup]?MovingAverage:[font = info; inactive; preserveAspect; endGroup]MovingAverage[list,n] returns a list of the n-th moving averages of   list.:[font = input; preserveAspect; startGroup]?NonlinearFit:[font = info; inactive; preserveAspect; endGroup]NonlinearFit[data,model,vars,params,(opts)] uses iterative methods   to fit the data to the model containing the given variables and   parameters.  Paramaters may be expressed as a list of symbols   or {symbol, startingvalue} pairs.  The data are given as {{x1,   y1, ..., f1},{x2, y2, ... f2},...}; some variations on this are   also valid (see documentation.):[font = input; preserveAspect]<<RAFAEL:Mathematica:Packages:NumericalMath:PolynomialFit.m(* <<RAFAEL:Mathematica:Packages:NumericalMath:SplineFit.m  *):[font = input; preserveAspect; endGroup]<<RAFAEL:Mathematica:Packages:Graphics:Spline.m:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Regression:[font = text; inactive; preserveAspect]Fit[  ]:[font = input; preserveAspect](* built-in Fit[] function 10x faster than Regress[] package *)linfit[n_,m_]:=Module[{v1sel,v2sel,datsel,line},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				line = Fit[ Transpose[{v1sel,v2sel}],{1,x},x]		]		linA[n_,m_]:= linfit[v[n],v[m]] [[1]];linB[n_,m_]:= linfit[v[n],v[m]] [[2,1]];:[font = text; inactive; preserveAspect]LinearRegression.m:[font = input; preserveAspect](* load external package for regression parameters *)<<RAFAEL:Mathematica:Packages:Statistics:LinearRegression.m  :[font = input; preserveAspect; startGroup]??Regress:[font = info; inactive; preserveAspect; endGroup]Regress[data, funs, vars] finds a least-squares fit to a list of data as a   linear combination of the functions funs of variables vars. The data can   have the form {{x1, y1, ..., f1}, {x2, y2, ..., f2}, ...}, where the   number of coordinates x, y, ... is equal to the number of variables in   the list vars.  The data can also be of the form {f1, f2, ...}, with a   single coordinate assumed to take values 1, 2, .... The argument funs can   be any list of functions that depend only on the objects vars.Attributes[Regress] = {Protected, ReadProtected}:[font = input; preserveAspect; startGroup]Options[Regress]  :[font = output; output; inactive; preserveAspect; endGroup]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,   BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,   ConfidenceLevel -> 0.95};[o]{OutputList -> Null, OutputControl -> Automatic, IncludeConstant -> True,    BasisNames -> Automatic, Weights -> Equal, Tolerance -> Automatic,    ConfidenceLevel -> 0.95}:[font = input; preserveAspect; endGroup]linR2[n_,m_]:= Module[{v1sel,v2sel,datsel,reg },		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];			reg = Regress[datsel,{1,x},x,		OutputControl-> NoPrint,		OutputList->{RSquared} 	(*BestFitCoefficients,BestFit *)		];				(* {a,b}=BestFitCoefficients /. reg[[1]]  *)		RSquared /. reg[[1]]	]	RSqr[dat_]:= Module[{reg},				reg = Regress[ dat, {1,x},x,					OutputControl ->NoPrint,					OutputList ->{RSquared}					];				RSquared /. reg[[1]]				]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]reference:[font = text; inactive; preserveAspect]Definitions and Symbols:[font = input; preserveAspect](* Symbols::= ||<=>=n_!======..&&N/;			"Provided that the following conditions are met:"_?NumberQ	*):[font = input; preserveAspect; startGroup]?Cases:[font = info; inactive; preserveAspect; endGroup]Cases[{e1, e2, ...}, pattern] gives a list of the ei that match the pattern.   Cases[{e1, ...}, pattern -> rhs] or Cases[{e1, ...}, pattern :> rhs] gives a   list of the values of rhs corresponding to the ei that match the pattern.   Cases[expr, pattern, levelspec] gives a list of all parts of expr on levels   specified by levelspec which match the pattern.:[font = input; preserveAspect; startGroup]?Select:[font = info; inactive; preserveAspect; endGroup]Select[list, crit] picks out all elements ei of list for which crit[ei] is True.   Select[list, crit, n] picks out the first n elements for which crit[ei] is True.:[font = input; preserveAspect; startGroup]? ?:[font = info; inactive; preserveAspect; endGroup]p?test is a pattern object that stands for any expression which matches   p, and on which the application of test gives True.:[font = input; preserveAspect; startGroup]? __:[font = info; inactive; preserveAspect; endGroup]__ (two _ characters) or BlankSequence[ ] is a pattern object that   can stand for any sequence of one or more Mathematica expressions.   __h or BlankSequence[h] can stand for any sequence of one or more   expressions, all of which have head h.:[font = input; preserveAspect; startGroup]? ___:[font = info; inactive; preserveAspect; endGroup]___ (three _ characters) or BlankNullSequence[ ] is a pattern object   that can stand for any sequence of zero or more Mathematica   expressions. ___h or BlankNullSequence[h] can stand for any   sequence of expressions, all of which have head h.:[font = input; preserveAspect; startGroup]? ..:[font = info; inactive; preserveAspect; endGroup]p.. is a pattern object which represents a sequence of one or more expressions, each   matching p.:[font = input; preserveAspect; startGroup]? ...:[font = info; inactive; preserveAspect; endGroup]p... is a pattern object which represents a sequence of zero or more expressions,   each matching p.:[font = input; preserveAspect; startGroup]{{},{},{}} //FullForm:[font = output; output; inactive; preserveAspect; endGroup]FullForm[{{}, {}, {}}];[o]List[List[], List[], List[]]:[font = text; inactive; preserveAspect]Searching for a String:[font = text; inactive; preserveAspect]You can write programs that manipulate external data. This program gives a list of the files in your current directory that contain a particular string.:[font = input; preserveAspect]Where[s_String] :=      Select[ FileNames[ ],                   (Length[FindList[#, s, 1]] > 0)& ]:[font = text; inactive; preserveAspect]Statistics:[font = text; inactive; preserveAspect]You can often avoid using loops in Mathematica  by operating directly on complete lists. The resulting programs are usually more elegant and more efficient. Here are programs for computing the mean, variance, and quantiles of a list.:[font = input; preserveAspect]Mean[list_List] := Apply[Plus, list] / Length[list]:[font = input; preserveAspect]Variance[list_List] := Mean[ (list - Mean[list])^2 ]:[font = input; preserveAspect]Quantile[list_List, q_] :=          Part[ Sort[list],              -Floor[-q Length[list]] ] /; 0 < q < 1:[font = text; inactive; preserveAspect]Reading and Plotting a Matrix:[font = text; inactive; preserveAspect]This program makes a three-dimensional plot of a matrix of numbers read from a data file.:[font = input; preserveAspect]FilePlot3D[file_String] :=           ListPlot3D[ ReadList[                 file, Number, RecordLists -> True] ]:[font = input; preserveAspect; startGroup]?RecordLists:[font = info; inactive; preserveAspect; endGroup]RecordLists is an option for ReadList which specifies whether objects   from separate records should be returned in separate sublists.:[font = text; inactive; preserveAspect]Scan max/min of vector:[font = input; preserveAspect; startGroup]??Append:[font = info; inactive; preserveAspect; endGroup]Append[expr, elem] gives expr with elem appended.Attributes[Append] = {Protected}:[font = input; preserveAspect; startGroup]?Scan:[font = info; inactive; preserveAspect; endGroup]Scan[f, expr] evaluates f applied to each element of expr in turn. Scan[f, expr,   levelspec] applies f to parts of expr specified by levelspec.:[font = input; preserveAspect]tmax[chan_]:= Block[{i=0, maxp},  maxp = Max[ vector ];  Scan[ ( If [ # < maxp , i++, Return[i], Return[]   ] )&, vector ]  ]:[font = input; preserveAspect; startGroup]i=1;maxp = Max[ vector ];Scan[ ( If [ # < maxp, i++, Return[i], Return[]   ] )&, vector ]:[font = output; output; inactive; preserveAspect; endGroup]9;[o]9:[font = input; preserveAspect; startGroup]i=1;minp = Min[ vector ];Scan[ ( If [ # > minp, i++, Return[i], Return[]   ] )&, vector ]:[font = output; output; inactive; preserveAspect; endGroup]6;[o]6:[font = input; preserveAspect; startGroup]binary = {1,1,1,0,0,1,1,1,1,1,0,0};i=1;Scan[ ( If [ # == 1, i++, Return[i], Return[]   ] )&, binary ]:[font = output; output; inactive; preserveAspect; endGroup; endGroup; endGroup]4;[o]4^*)