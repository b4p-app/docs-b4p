(* :Title: Discrete Wavelet Transformations *)(* :Authors: Alistair Rowe & Paul C. Abbott *)(* :Summary: This package calculates the discretewavelet transformation of a vector of dyadic length.It performs this calculation for any of the Daubechieswavelet bases up to order 28. In addition, a user mayselect the precision of the filter coefficients used in the calculation. For any Daubechies system up to order 18, any precision may be specified. However, for larger order systems, the maximum allowable precisionis the machine precision.The package will also allow the user to display the wavelet transform of a vector using a spectral densityplot *)(* :Context: WaveletTransform` *)(* :Package Version: 1.0 *)(* :Keywords: Daubechies wavelets, forward discretewavelet transform, inverse discrete wavelet transform,dyadic, quadrature mirror filters, spectral densityplot, recursion matrix, approximation condition, orthogonality condition, normalisation condition. *)(* :Source: Strang G (1989) Wavelets and DilationEquations: A Brief Introduction SIAM Review 31(4)614-627 *)(* :Source: Daubechies I (1992) Ten Lectures onWavelets 61 in CBMS-NSF Series in Applied Mathematics SIAM *)(* :Source: Newland D (1993) Introduction toRandom Vibrations, spectral and wavelet analysis3rd Ed. (Essex:Longman) 295-370 *)(* :Mathematica Version: 2.2 *)BeginPackage["WaveletTransform`"]Wavelet::usage="Wavelet[data,Daubechies[n]] evaluates the discrete wavelet transform of a dyadic (data) vector in theDaubechies basis, Daubechies[n]. Daubechies[n] may be of any order between 4 and 28 (i.e. D4, D6, etc...). It will return the transform vector of length equal tothe length of the real space vector (data).Wavelet[data] returns the discrete wavelet transformof the dyadic (data) vector in the Daubechies[4] basis."InverseWavelet::usage="InverseWavelet[data,Daubechies[n]] evaluates theinverse discrete wavelet transform of the dyadic vector (data) in the Daubechies basis, Daubechies[n]. It will return a real space vector of length equal to the length of the transform space vector (data).InverseWavelet[data] evaluates the inverse discretewavelet transform in the Daubechies[4] basis."SpectralDensityPlot::usage="SpectralDensityPlot[{w0,w1,w2,...},t] re-orders {w0,w1,w2,...} and displays the result using a spectral density plot with t tickmarks along the position axis. SpectralDensityPlot[{w0,w1,w2,...}] re-orders {w0,w1,w2,...} and displays the result using a spectral density plot with 4 tickmarks along the position axis."Daubechies::usage="Daubechies[n] gives the Dn hard coded filter coefficients. The coefficients are given to a precisionof 16."GenerateCoefficients::usage="GenerateCoefficients[n,x] may be used to generate theDn coefficients, {c0,c1,c2,...,cn}, to precision x. For systems of order 20 or greater, the maximum allowableprecision is the machine precision.GenerateCoefficients[n] generates the order n filter coefficients to machine precision."Begin["WaveletTransform`Private`"];(*------------------FILTER COEFFICIENTS----------------*)(* Hard code for Daubechies basis filter coefficients *)Daubechies::order = "The order of the systemyou have specified is either odd, or too large."Daubechies[4] = {0.4829629131445343,0.836516303737808, 			0.2241438680420133,-0.1294095225512605};												Daubechies[6] = {0.3326705529500825,0.806891509311093,			0.4598775021184916,-0.1350110200102546, 			-0.0854412738820267, 0.03522629188570954};			Daubechies[8] = {0.2303778133088965,0.7148465705529156,			0.6308807679298589,-0.0279837694168598, 			-0.1870348117190931,0.03084138183556075,  			0.03288301166688521,-0.01059740178506903}; 											Daubechies[10] = {0.1601023979741928,0.6038292697971896, 			0.724308528437773,0.1384281459013208, 			-0.242294887066382,-0.03224486958463841, 			0.07757149384004569,-0.006241490212798261,  			-0.01258075199908199,0.003335725285473768};												Daubechies[12] = {0.1115407433501097,0.4946238903984539, 			0.7511339080210954,0.3152503517091964, 			-0.2262646939654401,-0.1297668675672614,  			0.097501605587323,0.02752286553030555,  			-0.03158203931748598,0.0005538422011615153,  			0.0047772575109455,-0.001077301085308478}; 											Daubechies[14] = {0.07785205408500815,0.3965393194819149, 			0.729132090846235,0.4697822874051961, 			-0.1439060039285631,-0.2240361849938757,  			0.07130921926682931,0.0806126091510832,  			-0.038029936935014,-0.01657454163066694,  			0.01255099855609971,0.0004295779729213966,  			-0.001801640704047472,0.0003537137999745138};												Daubechies[16] = {0.05441584224310652,0.3128715909143076, 			0.6756307362972941,0.585354683654198, 			-0.01582910525635983,-0.2840155429615455,  			0.0004724845739186695,0.128747426620478,  			-0.01736930100180972,-0.04408825393079447,  			0.01398102791739896,0.00874609404740565,  			-0.004870352993451718,-0.0003917403733769095, 			0.0006754494064505847,-0.0001174767841247747};												 Daubechies[18] = {0.03807794736385691,0.2438346746124987, 			0.6048231236900107,0.6572880780513792, 			0.133197385825205,-0.2932737832791523,  			-0.0968407832230931,0.1485407493380991,  			0.03072568147939063,-0.06763282906133679,  			0.0002509471148116557,0.02236166212368554,  			-0.004723204757747662,-0.004281503682465658,  			0.001847646883056128,0.0002303857635234875,  			-0.0002519631889427702,0.00003934732031627362}; 											Daubechies[20] = {0.02667005790055421,0.188176800077688, 			0.5272011889317257,0.6884590394536087, 			0.2811723436605755,-0.2498464243273188,  			-0.1959462743773682,0.1273693403357946,  			0.0930573646035619,-0.07139414716639437,  			-0.02945753682186907,0.03321267405933686, 			0.003606553566954084,-0.01073317548332807,  			0.001395351747052848,0.001992405295184346,  			-0.0006858566949594908,-0.0001164668551292242,  			0.0000935886703200254,-0.00001326420289451455};												Daubechies[22] = {0.01869429776635844,0.1440670211843934, 			0.449899764442017,0.6856867749899943, 			0.4119643688790747,-0.1622752452003778,  			-0.2742308468710007,0.06604358829805259,  			0.1498120125148176,-0.04647995517162437,  			-0.06643878571815244,0.03133509024615421, 			0.02084090436650419,-0.01536482091695554, 			-0.003340858873279059,0.004928417659061647, 			-0.000308592859312958,-0.000893023251154705, 			0.0002491525237284434,0.00005443907472380634,  			-0.00003463498420770371,4.494274280077827*10^-6};												Daubechies[24] = {0.0131122579575879,0.1095662728233637, 			0.3773551352188081,0.6571987225814393, 			0.5158864784219289,-0.04476388566142976,  			-0.3161784537516211,-0.02377925725063712,  			0.1824786059270268,0.005359569671205142,  			-0.0964321200958421,0.01084913025726719,  			0.04154627749452594,-0.0122186490702154, 			-0.01284082519800503,0.006711499008877733,  			0.002248607240897579,-0.002179503618625406,  			6.545128230709719*10^-6,0.0003886530628166778,  			-0.0000885041092094991,-0.00002424154575639791,  			0.00001277695221932685,-(1.529071758073567*10^-6)};												Daubechies[26] = {0.00920213353931661,0.0828612438754295, 			0.3119963221669377,0.6110558511640636, 			0.5888895704249955,0.0869857261661467,  			-0.3149729077135111,-0.1245767307413014,  			0.1794760794315293,0.07294893365063891,  			-0.1058076181885949,-0.02648840647189621,  			0.0561394770999728,0.002379972252556501,  			-0.02383142070985787,0.003923941449240789,  			0.007255589401357135,-0.002761911234719797,  			-0.001315673911811168,0.000932326130860139,  			0.00004925152511340409,-0.0001651289885521143,  			0.00003067853757972681,0.00001044193057090021,  			-(4.700416479252781*10^-6),5.220035098376599*10^-7};												Daubechies[28] = {0.006461153456457243,0.06236475882286154, 			0.2548502677194104,0.5543056178658244, 			0.6311878491486145,0.2186706879198898,  			-0.2716885522051657,-0.2180335300890359,  			0.1383952137975193,0.1399890166450274,  			-0.0867484115289564,-0.07154895554296598,  			0.05523712624344248,0.02698140832982535,  			-0.03018535153721546,-0.005615049540059864,  			0.01278949326712221,-0.0007462189861748594,  			-0.003849638868911945,0.001061691084984728,  			0.0007080211545693207,-0.0003868319472621646,  			-0.00004177724583487526,0.00006875504253329038,  			-0.00001033720917924625,-(4.38970490323134*10^-6),  			1.7249946753747*10^-6,-(1.787139968074711*10^-7)};Daubechies[i_/; OddQ[i] || i > 28 || i < 4] :=				Message[Daubechies::order](* normalisation condition for filter coefficients *)Normalised[n_] := Sum[c[i],{i,0,n-1}] == Sqrt[2];(* approximation condition for filter coefficients *)A[n_,0] := Sum[c[i] (-1)^i,{i,0,n-1}]  == 0; A[n_,l_] := Sum[c[i] i^l*(-1)^i,{i,1,n-1}]  == 0; (* orthogonalisation conditions for filter coefficients *)Orth[n_,l_] := Sum[c[i] c[i+2 l],{i,0,n-1-2l}] == If[n==0,1,0];(* the system of equations to determine filter coefficients *)Sys1[n_] := Table[A[n,l],{l,0,-1+n/2}];Sys2[n_] := Table[Orth[n,l],{l,1,-1+n/2}];Equations[n_] := Equations[n] = 	Sys1[n] ~Join~ {Normalised[n]} ~Join~ Sys2[n];(* determining initial conditions for filter coefficientrecursion *)Fvals[2,x_] := Fvals[2,x] = {c[0] -> 1/2, c[1] -> 1/2};(* finding the values of the filter coefficients toa given precision *)Fvals[n_,x_] := Fvals[n,x] = FindRoot[Evaluate[Equations[n]], 	Evaluate[Init[n,x]], MaxIterations -> 100,		WorkingPrecision -> x];		subst[n_,x_] := Fvals[n-2,x];Previous[n_,x_] := Previous[n,x] = Table[c[i] /. 				subst[n,x],{i,0,(n-3)}];				Init[n_,x_]:= Init[n,x] = Sequence @@ Transpose[{Array[c,{n},0],				Previous[n,x] ~Join~ Table[0, {2}]}];(* Generate the list of filter coefficients in the order{c0,c1,c2,c3,c4,...} *)				GenerateCoefficients[n_,x_:$MachinePrecision] := 	If[OddQ[n] || n > 28 || n < 4, Message[Daubechies::order],		Table[c[i-1] /. Fvals[n,x], {i,1,n}]];(* --------------FORWARD WAVELET TRANSFORM--------------*)(* Define the high and low pass quadrature mirrorfilters *)QMFL[basis_] := QMFL[basis] = basis;QMFH[basis_] := QMFH[basis] = Reverse[basis] Table[				(-1)^(i+1),{i,1,Length[basis]}];(* Define a procedure for extending the data vectorin such a way that it is compatible with the basislength *)Extension[v_,bas_] := Table[v[[Mod[i-1,Length[v]]+1]],				{i,1,Length[v] + Length[bas] - 2}];(* The intermediate wavelet transform is applied iteratively to the real space vector or part thereof *)						Intermediate[data_,m_,basis_] :=	Module[{vect, vectcomp, l = Length[basis], L, H,				vl = Length[data]/(2^m)},			vect = Take[data,vl];		vectcomp = Drop[data,vl];		vect = Extension[vect,basis];				L = Table[QMFL[basis].Take[vect,{1+i,i+l}],{i,0,				Length[vect] - l,2}];		H = Table[QMFH[basis].Take[vect,{1+i,i+l}],{i,0,				Length[vect] - l,2}];						vect = L ~Join~ H ~Join~ vectcomp	];Warning::basis = "length of basis is not correct."Wavelet::error = "Vector length is not dyadic."	(* Wavelet definition *)	Wavelet[data_, basis_:Daubechies[4]] := Block[{n = -1},				Which[OddQ[Length[basis]], Message[Warning::basis],			IntegerQ[Log[2,Length[data]]],			(1/N[Sqrt[Length[data]]])*			Nest[(++n; Intermediate[#,n,basis])&, data, 				Log[2,Length[data]]],			True,Message[Wavelet::error]]	];(*----------------INVERSE WAVELET TRANSFORM-------------*)(* Define the inverse quadrature mirror filters *)InverseQMF[band_,basis_] := 	Block[{l = Length[basis],oddelem,evenelem,revodd,reveven,qmf},						oddelem = Table[basis[[i]],{i,1,l,2}];		evenelem = Table[basis[[i]],{i,2,l,2}];		revodd = Reverse[oddelem];		reveven = Reverse[evenelem];					If[TrueQ[band == l],			qmf = Flatten[Table[{revodd[[i]],evenelem[[i]]},						{i,1,Length[revodd]}]],			qmf = Flatten[Table[{reveven[[i]],-oddelem[[i]]},						{i,1,Length[reveven]}]]]		];	(* Define a procedure which matches the length of thetransform vector to the length of the basis *)InverseExtension[v_,bas_] := Table[v[[Mod[Length[v]+i-				Length[bas]+1,Length[v]]+1]],					{i,1,Length[v] + Length[bas] - 2}];(* Intermediate inverse transform definition *)InverseIntermediate[data_,m_,basis_] :=	Module[{v1, v2, v1comp, vl = 2^(m+1),l = Length[basis], L, H},			v1 = Take[data,vl];		v1comp = Drop[data,vl];				v2 = Flatten[Table[{v1[[i]],v1[[i+vl/2]]},					{i,1,vl/2}]];				v1 = InverseExtension[v2,basis];				L = Table[InverseQMF[l,basis].Take[v1,{1+i,i+l}],					{i,0,Length[v1] - l,2}];		H = Table[InverseQMF[h,basis].Take[v1,{1+i,i+l}],					{i,0,Length[v1] - l,2}];					v1 = Flatten[Table[{L[[i]],H[[i]]},					{i,1,Length[L]}]] ~Join~ v1comp	];InverseWavelet::error = "Vector length is not dyadic."(* Inverse wavelet transform definition *)InverseWavelet[data_,basis_:Daubechies[4]] := 	Block[{n = -1},		Which[OddQ[Length[basis]], Message[Warning::basis],			IntegerQ[Log[2,Length[data]]],			N[Sqrt[Length[data]]]*			Nest[(++n; InverseIntermediate[#,n,basis])&, 				data, Log[2,Length[data]]],			True,Message[InverseWavelet::error]		]	];(*------------------GRAPHICAL OUTPUT-----------------*)(* Re-arrange the transform space vector into the appropriate form for viewing on a spectral density plot *)PictFormat[data_] := Module[{l = Length[data], t1, t2},				t2 = Table[Take[data,{2^i + 1,2^(i+1)}][[j]],			{i,1,Log[2,l]-1},{j,1,2^i},{l/(2^i)}];								t1 = {Flatten[Table[{Take[data,1]},{l}]]} ~Join~			{Flatten[Table[{Take[data,{2,2}]},{l}]]} ~Join~				Table[Flatten[t2[[i]]],{i,1,Log[2,(l/2)]}]	];		scaleticks[n_] := Table[{i+1/2, i},{i,-1,n}];posticks[n_,m_] := Table[m i,{i,0,n/m}];				(* SpectralDensityPlot definition *)SpectralDensityPlot[list_?ListQ, numticks_:4] :=	Block[{dims,pos,scales},				dims = Dimensions[PictFormat[list]];		pos = Last[dims];		scales = First[dims];		ListDensityPlot[PictFormat[list]^2, 			Mesh -> False,			MeshRange -> {{1,pos},{-1,scales-1}},			FrameTicks -> {posticks[pos,pos/numticks], 				scaleticks[scales-2]},			Axes->True,AxesLabel->{"position","scale"}]	];				End[]; (* "WaveletTransform`Private`" *)SetAttributes[Daubechies,ReadProtected];SetAttributes[GenerateCoefficients,ReadProtected];SetAttributes[Wavelet,ReadProtected];SetAttributes[InverseWavelet,ReadProtected];SetAttributes[SpectralDensityPlot,ReadProtected];Protect[Daubechies,GenerateCoefficients,Wavelet,InverseWavelet,SpectralDensityPlot];EndPackage[]; (* "WaveletTransform`" *)