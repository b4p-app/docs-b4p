(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.2";	MacintoshStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, a2, e2,  24, "Helvetica"; 	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, a2, e2,  18, "Helvetica"; 	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic, a2, e2,  10, "Helvetica"; 	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, a2, e2,  18, "Helvetica"; 	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, a2, e2,  14, "Helvetica"; 	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, a2, e2,  12, "Helvetica"; 	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a1, e2,  12, "Times"; 	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a1, e2,  10, "Times"; 	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-5, a1, e2,  10, "Courier"; 	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a1, e2,  9, "Courier"; 	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R65535, L-5, a1, e2,  9, "Courier"; 	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5, a1, e2,  9, "Courier"; 	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B65535, L-5, a1, e2,  9, "Courier"; 	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, w453, h459, a2, e2,  12, "Courier"; 	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic, B65535, a2, e2,  9, "Geneva"; 	fontset = header, inactive, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = leftheader, inactive, L2, a2, e2,  12, "Times"; 	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, center, M7, a2, e2,  12, "Times"; 	fontset = leftfooter, inactive, L2, a2, e2,  12, "Times"; 	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Times"; 	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  10, "Courier"; 	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, a2, e2,  12, "Times"; 	paletteColors = 128; currentKernel; ]:[font = title; inactive; dontPreserveAspect; fontSize = 18; startGroup]User Mathematicaª   Initialization File;[s]3:0,0;5,1;17,0;40,-1;2:2,19,14,Helvetica,1,18,0,0,0;1,19,14,Helvetica,3,18,0,0,0;:[font = text; inactive; preserveAspect]     This file is read in every time the Mathematica kernel is started up.  You can insert anything you like in the following cell(s).  For example, if you have defined a function you use very often, you can put it in this file, and it will be loaded every time you use Mathematica.     You can also add new folders to the kernel search path.  If you have several Notebook you want to be able to load in using the kernel file reading function "<<filename ", you can put them together in a folder and add its path name to the list below.;[s]7:0,0;41,1;52,0;270,1;281,0;447,1;456,0;538,-1;2:4,13,9,Times,0,12,0,0,0;3,13,9,Times,2,12,0,0,0;:[font = subsubsection; inactive; Cclosed; dontPreserveAspect; startGroup]Path:[font = text; inactive; initialization; dontPreserveAspect]To add a folder to the kernel search path, put a line like the following in the initialization cell below.$Path = Join[$Path, {"HD20:Mathematicaª Data:My Notebooks "}]Add one such line for each folder you want to add to the path.  The path name in quotes must be the complete path name of the folder.  The example given is for a folder named "My Notebooks" which is in another folder named "Mathematicaª Data" on a disk named "HD20".  Note the colons between disk/folder names.;[s]3:0,0;130,1;166,0;482,-1;2:2,13,9,Times,0,12,0,0,0;1,13,9,Times,2,12,0,0,0;:[font = input; initialization; wordwrap; dontPreserveAspect; endGroup]*) (*:[font = subsubsection; inactive; Cclosed; dontPreserveAspect; startGroup]Default ViewPoint:[font = text; inactive; initialization; dontPreserveAspect]     If you want to permanently change the default viewpoint for 3D graphics, you can do it by editing the cell below, and then making the cell active (use the Inactive command in the Cell menu).  To adjust the default viewpoint, do the following:          1) Select the text "ViewPoint->{x, y, z}" in the cell below.     2) Bring up the 3D ViewPoint Selector dialog box (using the command in the Prepare Input submenu of the Action menu).     3) Use the mouse to select the viewpoint you want in the dialog box.     4) Click the Paste Button.     5) Choose Inactive from the Cell menu (if it is not currently checked, then don't choose it).     6) Choose Save from the file menu.          The next time you restart Mathematica, the cell below will be evaluated, which will reset the default viewpoint for that session.;[s]9:0,0;160,1;168,0;564,1;572,0;663,1;667,0;725,2;736,0;829,-1;3:5,13,9,Times,0,12,0,0,0;3,13,9,Times,1,12,0,0,0;1,13,9,Times,2,12,0,0,0;:[font = input; inactive; initialization; wordwrap; dontPreserveAspect; endGroup]SetOptions[   {Plot3D, ListPlot3D, Graphics3D, SurfaceGraphics},   ViewPoint->{x, y, z}];:[font = subsubsection; inactive; dontPreserveAspect; startGroup]User Initialization:[font = text; inactive; dontPreserveAspect]Insert anything you would like to be evaluated every time the kernel is started up in the initialization cell below::[font = section; inactive; initialization; preserveAspect; startGroup]BICS ANALYSIS - rev.  07.25.96:[font = subsubsection; inactive; initialization; Cclosed; preserveAspect; startGroup]Input File Format:[font = smalltext; inactive; initialization; preserveAspect; endGroup]FORMAT of files* Saved as MACINTOSH format from BBEdit* Number of variables must match number of valid data columns* ASCII file* TAB delimited* NL at end of each lineFILE HEADER* First row:  contains two numbers: number of columns (tab) number of rows* Second row:  variable names (separated by tabs)* Third and later rows:  data columns. NAMES of variables and files* VALID - Alphanumeric string of any length, beginning with character, or containing underscore "_"								EEG,  EEG1, EEG_1			* INVALID - containing operator symbols (minus, plus, division, decimal point,equals) :								EEG.1, EEG-1, EEG+1, EEG/1, EEG=*May not begin with a number or operator								1EEG:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]startup:[font = input; initialization; preserveAspect; endGroup]*)(* Input["Enter File Name: "] //ToString; *)(* streams:  String=linebuf \n; Word= wordbuf \t *)(*  !!filename		display contents *)(* Put relevant data and package files in path *)(* MAC *)$Path = Join[$Path, {"PB:Apps:Mathematica:Packages:Statistics "}];(* WIN  $Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\numerica\\"}];$Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\graphics\\"}];$Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\preload\\"}];$Path = Join[$Path, {"c:\\richards\\bics"}];filePath = "c:\\richards\\bics\\"*)(* -------- SET DIRECTORY -------------- *)(*FileInformation["file"] *)SetDirectory["Project:BICS:data"];(*---------- TURN OFF SYMBOL WARNING pp386 SWolf ----*)Off[General::newsym];lineSeparator ="------------------------------------------------------------------------------------\r";(* ------DEFAULT VARIABLE NAMES-------*)var = {			Hours, var2, var3, var4, var5, var6, var7, var8, var9, var10,		var11, var12, var13, var14, var15, var16, var17, var18, var19, var20,		var21, var22, var23, var24		};(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]dir:[font = input; initialization; preserveAspect; startGroup]*)Clear[dir];dir = Module[{dirname,dirs,files,numfiles},			dirname  = StringJoin["DIRECTORY:  ", Directory[] ];		files 	 = FileNames[];		dirs     = FileNames["*.*"];		numfiles = StringJoin["FILES:      ", ToString[Length[files] ] ];		numdirs	 = StringJoin["DIRS :      ", ToString[Length[dirs] ] ];						Print[dirname];		Print[numdirs];		Print[numfiles];				printList[files,4]//MatrixForm		];(*:[font = print; inactive; initialization; preserveAspect; endGroup; endGroup]DIRECTORY:  Project:BICS:dataDIRS :      4FILES:      18:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]printList[ list, width]:[font = input; initialization; preserveAspect; startGroup]*)(* pad item list so the number of columns is integer divisor of total number of items *)Clear[printNumList];printNumList[ lis_List, printWidth_Integer ]:=Module[{},		width=printWidth;		len=Length[lis];	nulls = width - Mod[ len,width];	nulltable = Table["-", {nulls}];	lisPadded=Append[lis,nulltable]//Flatten;			index=Table[i, {i, 1,Length[lisPadded] } ];	pairs=Transpose[{index,lisPadded}];	lines=Partition[pairs,width];	Return[lines]	](*:[font = input; initialization; preserveAspect; endGroup; endGroup]*)Clear[printList];printList[ lis_List, printWidth_Integer ]:=Module[{},		width = printWidth;	len=Length[lis];		nulls = width - Mod[ len,width];	nulltable = Table["-", {nulls}];	lisPadded=Append[lis,nulltable]//Flatten;	lines=Partition[lisPadded,width];	Return[lines]	]	(*:[font = subsubsection; inactive; initialization; Cclosed; preserveAspect; startGroup]Read:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]readFileOut[ "file"]:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]extra:[font = input; initialization; preserveAspect; endGroup]*)(* EXTRA FUNCTIONS----- calculate time var -----	begT   =  data[[1,1]] ;	endT   =  data[[dataRows,1]] ;	deltaT = endT-begT;	Print["Elapsed time: \t",deltaT];----- display index,varname,firstval -----outTable=Table[ StringJoin[	"[",ToString[i],"] ",varNames[[i]],"\t",ToString[data[[1,i]] ]  ],	{i,1,nCols}	];	Return[ printList[outTable,3] //MatrixForm];*)(*:[font = input; initialization; preserveAspect; endGroup]*)readFileOut[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},		Clear[nRows,nCols,varNames,data];	stream1=OpenRead[fileName];	SetStreamPosition[stream1,0];(*----- read header -----*)	nRows=Read[stream1, Number];	nCols=Read[stream1, Number];	Print["nRows: \t\t\t", nRows];	Print["nCols: \t\t\t", nCols];		varFormat=Table[Word, {nCols}];	dataFormat=Table[Number,{nCols}];(*----- read var names -----*)	varNames=Read[ stream1, varFormat];	Print["Vars: \t\t\t", varNames ];	(*---- read in data -----*)	Print["reading rows..."];	dataRows=0;	data={{}};				(* create empty array *)	For[i=1, i<=nRows,i++,		line= Read[ stream1, dataFormat];				If[ line[[1]] != -999,			AppendTo[data, line];	(* probably spends much time										allocating memory here... *)			dataRows++			,Null			];				If[ Mod[i,500]==0, Print["\t\t\t\t",i] ];		];			nRows = dataRows;		Print["\t\t\t\t",nRows];		(*----- drop the first,empty, member of data -----*)	data= Drop[data,1];		Print["\t\t\t\t","DONE READING FILE"];];(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]readFileReg[ "file"]:[font = input; initialization; preserveAspect; endGroup]*)readFileReg[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},		Clear[nRows,nCols,nCases,nVars,varNames,data];		stream1=OpenRead[fileName];	SetStreamPosition[stream1,0];(*----- read header -----*)	nRows  = Read[stream1, Number];	nCols  = Read[stream1, Number];	nCases = Read[stream1,Number];	nVars  = Read[stream1,Number];		Print["nRows: \t\t\t", nRows];	Print["nCols: \t\t\t", nCols];	Print["nCases:\t\t\t", nCases];	Print["nVars: \t\t\t", nVars];		varFormat=Table[Word, {nVars}];	dataFormat=Table[Number,{nCols}];(*----- read var names -----*)	varNames=Read[ stream1, varFormat];	Print["varNames: \t\t", varNames ];	(*---- read in data -----*)	Print["reading rows..."];	dataRows=0;	data={{}};				(* create array *)	For[i=1, i<=nRows,i++,		line= Read[ stream1, dataFormat];				If[ line[[1]] != -999,			AppendTo[data, line]; dataRows++,			Null			];				If[ Mod[i,500]==0, Print["\t\t\t\t",i] ];		];			nRows = dataRows;		Print["\t\t\t\t",nRows];			(*----- drop the first,empty, member of data -----*)	data= Drop[data,1];			Print["\t\t\t\t","DONE READING FILE"]	];(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]readFileLag[ "file"]:[font = input; initialization; preserveAspect; endGroup; endGroup]*)readFileLag[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},		Clear[nRows,nCols,nCases,nVars,varNames,data];		stream1=OpenRead[fileName];	SetStreamPosition[stream1,0];(*----- read header -----*)	nRows  = Read[stream1, Number];	nCols  = Read[stream1, Number];	nCases = Read[stream1,Number];	nVars  = Read[stream1,Number];		Print["nRows: \t\t\t", nRows];	Print["nCols: \t\t\t", nCols];	Print["nCases:\t\t\t", nCases];	Print["nVars: \t\t\t", nVars];		varFormat=Table[Word, {nVars}];	dataFormat=Table[Number,{nCols}];(*----- read var names -----*)	varNames=Read[ stream1, varFormat];	Print["varNames: \t\t", varNames ];	(*---- read in data -----*)	Print["reading rows..."];	dataRows=0;	data={{}};				(* create array *)	For[i=1, i<=nRows,i++,		line= Read[ stream1, dataFormat];				If[ line[[1]] != -999,			AppendTo[data, line]; dataRows++,			Null			];				If[ Mod[i,500]==0, Print["\t\t\t\t",i  ] ];		];			nRows = dataRows;		Print["\t\t\t\t",nRows];			(*----- drop the first,empty, member of data -----*)	data= Drop[data,1];			Print["\t\t\t\t","DONE READING FILE"]	];(*:[font = subsubsection; inactive; initialization; Cclosed; preserveAspect; startGroup]Select:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]selColsRows[ data,c1,c2,r1,r2]    -> v1, v2:[font = input; initialization; preserveAspect; endGroup]*)selColsRows[data_,c1_,c2_,row1_,row2_]:=Module[{},		v1=v2={};		For[ i=row1, i<=row2, i++,						If[ (data[[i,c1]] != -999) && (data[[i,c2]] != -999),				AppendTo[ v1, data[[i,c1]] ];				AppendTo[ v2, data[[i,c2]] ];				];			];				Return[ {v1, v2}];		]				(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]selCaseCols3[ data,caseNo,c1,c2,c3]    -> vars, v1, v2, v3:[font = input; initialization; preserveAspect; endGroup]*)Clear[selCaseCols3];selCaseCols3[data_,caseNo_,c1_,c2_,c3_]:=Module[{i,v1,v2,v3,vars},v1=v2=v3={};For[ i=1, i<=nRows, i++,	If[ data[[i,1]] == caseNo, 		vars = {data[[i,2]], data[[i,3]] };		If[data[[i,c1]] != -999 && data[[i,c2]] != -999 &&  data[[i,c3]] != -999,			AppendTo[ v1, data[[i,c1]] ];			AppendTo[ v2, data[[i,c2]] ];			AppendTo[ v3, data[[i,c3]] ]			  ];	  ];   ];   {vars,v1, v2, v3 }//Return];(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]selCaseCols2[ data,caseNo,c1,c2,c3]    -> vars, v1, v2:[font = input; initialization; preserveAspect; endGroup]*)Clear[selCaseCols2];selCaseCols2[data_,caseNo_,c1_,c2_]:=Module[{i,v1,v2,vars},v1=v2={};For[ i=1, i<=nRows, i++,	If[ data[[i,1]] == caseNo, 		vars = {data[[i,2]], data[[i,3]] };		If[data[[i,c1]] != -999 && data[[i,c2]] != -999,			AppendTo[ v1, data[[i,c1]] ];			AppendTo[ v2, data[[i,c2]] ];		  ];	  ];   ];   {vars,v1, v2 }//Return];(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]selColsRowsDeriv[ data,c1,c2,r1,r2, d1,d2]  -> v1, v2:[font = input; initialization; preserveAspect; endGroup; endGroup]*)(* 	c1,c2:	column1, column2	r1,r2:	row1, row2	d1,d2:	first, second derivative cutoff values*)selColsRowsDeriv[data_,c1_,c2_,row1_,row2_,slope1_, slope2_]:=Module[{},	(*----- eliminate missing data -----*)	v1=v2={};	For[ i=row1, i<=row2, i++,				If[ (data[[i,c1]]!=-999) && (data[[i,c2]]!=-999),			AppendTo[ v1, data[[i,c1]] ];			AppendTo[ v2, data[[i,c2]] ];			];		];			(*----- 1st & 2nd derivative test -----*)	vec1=vec2={};	For[i=2, i<= Length[v2]-1, i++,		FLAG=1;			If[ Abs[v2[[i+1]] - v2[[i]]  ]  >= slope1,  			FLAG=0 ];		If[ Abs[v2[[i]] - v2[[i-1]]  ]  >= slope1,  			FLAG=0 ];		If[ Abs[v2[[i+1]] - 2 v2[[i]] + v2[[i-1]] ]  >= slope2,	FLAG=0 ];			If[ FLAG != 0, 	AppendTo[ vec1, v1[[i]]  ];						AppendTo[ vec2, v2[[i]]	 ], 	];		];Return[{vec1,vec2}];]				(*:[font = subsubsection; inactive; initialization; preserveAspect; startGroup]Plot:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]plotVecs[ v1,v2]:[font = input; initialization; preserveAspect; endGroup]*)plotVecs[v1_, v2_]:=Module[{},	minV1=Min[ v1 ];	maxV1=Max[ v1 ];	lenV1=Length[v1];		(*need min 5 non-missing points to plot *)			If[  lenV1 < 5, Print["N too small to plot"],						plotdat=Transpose[ {v1,v2}];				xlabel = "v1";			ylabel = "v2";			plotname=StringJoin["N: ",ToString[lenV1] ];						ListPlot[ plotdat,				PlotStyle->{PointSize[.001]},				PlotRange->{minV1, maxV1};				DefaultFont :> {"Courier",9},				Frame -> True,				PlotLabel-> plotname,				FrameLabel->{xlabel,ylabel},				RotateLabel->False				]			]			](*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]plotVecsMD[ v1,v2]:[font = input; initialization; preserveAspect; endGroup]*)plotVecsMD[vec1_, vec2_]:=Module[{},		v1=v2={};		For[ i=1, i<=Length[vec1], i++,						If[ (vec1[[i]] != -999) && (vec2[[i]] != -999),				AppendTo[ v1, vec1[[i]] ];				AppendTo[ v2, vec2[[i]] ];				];			];			minV1=Min[ v1 ];	maxV1=Max[ v1 ];	lenV1=Length[v1];			(*need min 5 non-missing points to plot *)			If[  lenV1  < 5, Print["N too small to plot"],						plotdat=Transpose[ {v1,v2}];				xlabel = "v1";			ylabel = "v2";			plotname=StringJoin["N: ",ToString[lenV1] ];						ListPlot[ plotdat,				PlotStyle->{PointSize[.001]},				PlotRange->{minV1, maxV1};				DefaultFont :> {"Courier",9},				Frame -> True,				FrameLabel->{xlabel,ylabel},				PlotLabel-> plotname,								RotateLabel->False				]			]			](*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]plotCols[ data, c1,c2, r1, r2]:[font = input; initialization; preserveAspect; endGroup]*)plotCols[data_,c1_, c2_, r1_, r2_]:=Module[{},	{v1,v2} = selColsRows[data,c1,c2,r1,r2];	minV1=Min[ v1 ];	maxV1=Max[ v1 ];	lenV1=Length[v1];		(*need min 5 non-missing points to plot *)			If[  lenV1 > 5,						plotdat=Transpose[ {v1,v2}];				xlabel = varNames[[c1]];			ylabel = varNames[[c2]];			plotname=StringJoin["N: ",ToString[lenV1] ];								ListPlot[ plotdat,				PlotStyle->{PointSize[.001]},				PlotRange->{minV1, maxV1};				DefaultFont :> {"Courier",9},				Frame -> True,				FrameLabel->{xlabel,ylabel},				PlotLabel-> plotname,										RotateLabel->False				]			]			];(*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]plotColsDeriv[ data, c1,c2, r1, r2, d1,d2]:[font = input; initialization; preserveAspect; endGroup]*)plotColsDeriv[data_,c1_, c2_, r1_, r2_, slope1_, slope2_]:=Module[{},	{v1,v2} = selColsRowsDeriv[data,c1,c2,r1,r2, slope1, slope2];	minV1=Min[ v1 ];	maxV1=Max[ v1 ];	lenV1=Length[v1];		(*need min 5 non-missing points to plot *)			If[  lenV1 > 5,						plotdat=Transpose[ {v1,v2}];				xlabel = varNames[[c1]];			ylabel = varNames[[c2]];			plotname=StringJoin["N: ",ToString[lenV1] ];						ListPlot[ plotdat,				PlotStyle->{PointSize[.001]},				PlotRange->{minV1, maxV1};				DefaultFont :> {"Courier",9},				Frame -> True,				FrameLabel->{xlabel,ylabel},				PlotLabel-> plotname,										RotateLabel->False				]			]			];(*:[font = text; inactive; initialization; preserveAspect; startGroup]plotSlopesR2[vars,v1,v2,v3]:[font = input; initialization; preserveAspect; endGroup]*)plotSlopesR2[vars_,v1_, v2_, v3_]:=	Module[{Nvalid,tCol,rCol,bCol,bMin,bMax,xMin,xMax,xRange,			yMin,yMax,rLocal,theta,xLocal,yLocal,ptsEnd,ptsCenter,points,lines,			xlabel,ylabel,plotlabel			},		Nvalid = Length[v1];						If[ Nvalid <=3, Null,				tCol = v1;				bCol = v2;				rCol = v3;				tMin  = Min[tCol];				tMax  = Max[tCol];												bMin  = Min[bCol];				bMax  = Max[bCol];							xMin  = Min[tCol];				xMax  = Max[tCol];				xRange = xMin-xMax;								yMin  = Min[rCol];				yMax  = Max[rCol];				(*----------------------------*)				rLocal   = 1.0;						(* radius of circle *)				theta  = - ArcTan[bCol];				xLocal = rLocal Cos[theta];				yLocal = rLocal Sin[theta]/xRange;	(* scale y by xRange *)					ptsEnd = Table[{{ tCol[[i]] + xLocal[[i]], rCol[[i]] + yLocal[[i]] },							 { tCol[[i]] - xLocal[[i]], rCol[[i]] - yLocal[[i]] }},												{i,1,Nvalid}							];											ptsCenter = Table[	{ tCol[[i]], rCol[[i]] },								{i,1,Nvalid}								];				points = Prepend[Map[Point,ptsCenter],  AbsolutePointSize[3]  ];				lines =  Prepend[Map[Line, ptsEnd],  AbsoluteThickness[.001]  ];				(*----------------------------*)				xlabel = "Hours";				ylabel = "R^2";												plotlabel = StringJoin[	varNames[[ vars[[1]]  ]],										" vs ",										varNames[[  vars[[2]] ]],										" // N:",										ToString[Nvalid],										"   B:",										ToString[PaddedForm[bMin,{5,4}]],										"...",										ToString[PaddedForm[bMax,{5,4}]]										];																			Show[ Graphics[points], Graphics[lines],						PlotRange->{{tMin,tMax},{-0.1,1.0}},						DefaultFont :> {"Courier",9},						Frame -> True,						FrameLabel->{xlabel,ylabel},						RotateLabel -> False,						PlotLabel->FontForm[plotlabel,{"Courier",9}]					 ]				]			]						(*			PlotRange->{{xMin-1,xMax+1},{-0.1,1.0}},			*)(*:[font = input; preserveAspect; startGroup]vars:[font = output; output; inactive; preserveAspect; endGroup]{13, 14};[o]{13, 14}:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]plotLagR2[vars,v1,v2]:[font = input; initialization; preserveAspect; endGroup]*)plotLagR2[vars_,v1_, v2_]:=	Module[{Nvalid,tCol,rCol,xMin,xMax,			yMin,yMax,rLocal,theta,xLocal,yLocal,ptsEnd,ptsCenter,points,lines,			xlabel,ylabel,plotlabel			},		Nvalid = Length[v1];						If[ Nvalid <=3, Null,											xMin  = Min[v1];				xMax  = Max[v1];								yMin  = Min[v2];				yMax  = Max[v2];								i=1;				While[  v2[[i]] < yMax, i++];				lagVal = v1[[i]];									(*----------------------------*)				xlabel = "Lag";				ylabel = "R^2";												plotlabel = StringJoin[	varNames[[ vars[[1]]  ]],										" vs ",										varNames[[  vars[[2]] ]],										" // N:",										ToString[Nvalid],										"  R^2 :",										ToString[PaddedForm[yMax,{5,4}]],										"  Lag: ",										ToString[ lagVal ]										];				plotdat=Transpose[ {v1,v2}];					ListPlot[ plotdat,					PlotStyle->{PointSize[.001]},					(* PlotRange->{{xMin,xMax},{-0.1,1.0}},  *)					DefaultFont :> {"Courier",9},					Frame -> True,					FrameLabel->{xlabel,ylabel},					RotateLabel->False,					PlotLabel->FontForm[plotlabel,{"Courier",9}]					]			]	]			(*:[font = text; inactive; initialization; preserveAspect; startGroup]plotFile[  " *.ext " ]:[font = input; initialization; preserveAspect; endGroup; endGroup]*)plotFile[ filename_String ]:=Module[{extension},	extension = StringTake[filename,-3];			(*---   *.OUT  ----*)	If[ StringMatchQ[ extension, "out" ],		readFileOut[filename];		For[ k=2, k<=nCols,k++,			plotCols[data,1,k,1,nRows]			]		];			(*---   *.REG   ---*)	If[ StringMatchQ[ extension, "reg" ],		readFileReg[filename];			For[ k=1, k<=nCases,k++,			{vars,v1,v2,v3}=selCaseCols3[data,k,4,5,6];					plotSlopesR2[vars,v1,v2,v3]			]		];				(*---   *.LAG   ---*)	If[ StringMatchQ[ extension, "lag" ],		readFileLag[filename];			For[ k=1, k<=nCases,k++,			{vars,v1,v2}=selCaseCols2[data,k,4,5];					plotLagR2[vars,v1,v2]			]		];				](*:[font = subsubsection; inactive; initialization; preserveAspect; startGroup]Regress:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]Tcrit[ dof ]                           (p<.005):[font = input; initialization; preserveAspect]*)(*p005=ReadList["Mac:BICS:p005",{Number,Number}];mu005 = Transpose[p005] [[1]];t005 = Transpose[p005] [[2]];  *)(*:[font = input; initialization; preserveAspect]*)muCrit = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 160, 170, 180, 190, 200, 250, 300, 350, 400, 450, 500, 600, 700, 800, 900, 1000, 1000000};(*:[font = input; initialization; preserveAspect]*)t005 = {63.657, 9.925, 5.841, 4.604, 4.032, 3.707, 3.499, 3.355, 3.25,   3.169, 3.106, 3.055, 3.012, 2.977, 2.947, 2.921, 2.898, 2.878, 2.845, 2.845,   2.831, 2.819, 2.807, 2.797, 2.787, 2.779, 2.771, 2.763, 2.756, 2.75, 2.744,   2.738, 2.733, 2.728, 2.724, 2.719, 2.715, 2.712, 2.708, 2.704, 2.701, 2.698,   2.695, 2.692, 2.69, 2.687, 2.685, 2.682, 2.68, 2.678, 2.674, 2.67, 2.667,   2.663, 2.66, 2.657, 2.655, 2.652, 2.65, 2.648, 2.646, 2.644, 2.642, 2.64,   2.639, 2.637, 2.636, 2.634, 2.633, 2.632, 2.63, 2.629, 2.628, 2.627, 2.626,   2.623, 2.621, 2.619, 2.617, 2.616, 2.614, 2.613, 2.611, 2.61, 2.609, 2.607,   2.605, 2.603, 2.602, 2.601, 2.596, 2.592, 2.59, 2.588, 2.587, 2.586, 2.584,   2.583, 2.582, 2.581, 2.581, 2.5758};(*:[font = input; initialization; preserveAspect; endGroup]*)Tcrit[dof_]:=Module[{},		(* index of critical t-value *)	iCrit[val_]:=				Do[ If[			muCrit[[i]] <= val && muCrit[[i+1]] >= val,					Return[i +1], Null					],			{i,0,Length[muCrit]-1}			];				Return[ t005[[ iCrit[dof]  ]]  ]		](*:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]R2[xdat, ydat]                      (= -500 if p>.005   and   = -999 if N<3 ):[font = input; initialization; preserveAspect; startGroup]*)(* If T>Tcrit then p>.005, and printed R2-> -500, a missing value *)  R2[Xdat_,Ydat_]:=Module[{	Ndat,totDF,regDF,resDF,Xsum,Ysum, 							XYsum,YYsum,XXsum,xySS,xxSS,yySS, 							totSS,regSS,resSS, 							totMS,regMS,resMS,Sxy, 							b,Sb,t,rSqr,rSqrCrit	},			vMean[list_List] := Apply[Plus, list] / Length[list];	vSum[list_List]:=Apply[Plus, list];	Ndat = Length[Xdat];		totDF = Ndat -1;	regDF = 1;	resDF = Ndat - 2;			(* residual DOF *)(* PROTECT FROM NULL DATA *)If[ Ndat <= 3, Return[-999],				Xsum = Xdat //vSum;	Ysum = Ydat //vSum;		XYsum = Xdat Ydat //vSum;	YYsum = Ydat Ydat //vSum;	XXsum = Xdat Xdat //vSum;		xySS  = XYsum - (Xsum Ysum)/Ndat;	xxSS  = XXsum - (Xsum Xsum)/Ndat;	(* xxSS *)	yySS  = YYsum - (Ysum Ysum)/Ndat;		totSS = yySS;	regSS = (xySS)^2/xxSS;	resSS = totSS - regSS;		(* residual sum of squares *)		totMS = totSS/totDF;	regMS = regSS/regDF;	resMS = resSS/resDF;	Sxy = Sqrt[resMS];	(*VARIABLES	b			slope	Sb			SE: std error of estimate (of slope)	rSqr		coeff of determination	rSqrCrit	adjusted rSqr for p<.005 significance	*)		b     = xySS/xxSS;				Sb	  = Re[Sqrt[Sxy^2/xxSS]];	(* take real part *)	If[ Sb==0, Sb= .000001 ]; 		(* avoid zero division *)	t     = b/Sb;			rSqr  = regSS/totSS ;					(* 	CHECK CRITICAL T-VALUE: significance of R2 *)		(* if p>.005,  rSqrCrit -> -500(or -999) *)		If[ t < Tcrit[resDF], rSqrCrit = -999,	rSqrCrit = rSqr];		output={rSqrCrit,b};		Return[output]	]							];(*:[font = input; initialization; preserveAspect; endGroup; endGroup]:[font = text; inactive; initialization; Cclosed; preserveAspect; startGroup]lagR2[v1,v2, lag]:[font = input; initialization; preserveAspect; endGroup; endGroup; endGroup; endGroup; endGroup]*)Clear[lagR2];lagR2[v1_,v2_, lag_]:=Module[{},	lenV=Length[v1];	len= lenV-Abs[lag];	If[len <=3, Print["N<3 data for lag: ",lag]; Return[{lag,-999}],							v1Lag= Drop[v1, - Sign[lag] Abs[lag] ];	(*rotate left/right*)		v2Lag= Drop[v2,   Sign[lag] Abs[lag] ];	(*rotate right/left*)				result=R2[ v1Lag, v2Lag];		Print[lag,"\t\t",result[[1]] ];		Return[{lag, result[[1]]} ];			];	];		(*^*)