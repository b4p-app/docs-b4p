(*^Evoked Potential Analysis1994  Rafael RichardsCodeData Input(*  numCols = Input["Expected number of columns in dataset: " ]    *)(* Put relevant data and package files in path *)$Path = Join[$Path, {"RAFAEL:Apps:Mathematica:Packages:Statistics "}];$Path = Join[$Path, {"RAFAEL:Apps:Mathematica:Packages:Graphics "}];$Path = Join[$Path, {"RAFAEL:Apps:Mathematica:Packages:NumericalMath "}];$Path = Join[$Path, {"RAFAEL:Temperature:data"}];numCols 	= 25;inputformat = Table[ Number, {numCols}];filename	= "albert.dat";data 		= ReadList[filename,inputformat];col = Transpose[data];v[n_]:= col[[n]]numRows = Length[data];casenum = Range[ numRows];numPoints = numRows*numCols;dataInfo  := Block[ { },   Print["File analyzed :           ", filename ];   Print["Rows in raw data:         ", numRows ];   Print["Columns in raw data:      ", numCols  ];   Print["Total data points:        ", numPoints  ]];dataInfoFile analyzed :           albert.datRows in raw data:         673Columns in raw data:      25Total data points:        16825Variable Names(* To ask the system which variable one is operating on, define	the list of variables *)	vars = {	PtNo, 	Dtime, Time, 	TempDel, Ntemp, Rtemp,				Incis, IMA, Stern, CPB, Cool,				erbL,	p10L,	n13L,	n18L,	n20L, p22L, AmpL,			erbR,			n13R,	n18R,	n20R, p22R, AmpR,				Event			};var[n_]:= vars[[n]](* check lengths are equal *)TrueQ[Length[vars] == numCols]Range SelectionselAll = Table[True, {numRows}];selNone= Table[False, {numRows}];(* Initially set selection to all cases *)sel = selAll;SelectYRange[n_, ymin_, ymax_]:= 	Do[ If[ 				N[ v[n][[i]] ] <=  ymin  ||  N[ v[n][[i]] ] >=  ymax, Null, 						sel[[i]] = False],	{i,1,numRows}	];(* Selects cases of variable[n] that falls in min/max range *)SelectNonZero[n_]:= 			Do[ If[   	v[n][[i]]  != 0., Null,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are zero *)	SelectNonMissing[n_]:= 			Do[ If[  v[n][[i]] <= -500. || v[n][[i]] >= 500., 										sel[[i]] = False, Null],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are missing data *)	SelectON[n_]:= 			Do[ If[   	v[n][[i]]  = 1.,  ,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 1 *)	SelectOFF[n_]:= 			Do[ If[   	v[n][[i]]  = 0.,  ,sel[[i]] = False],				{i,1, numRows}			  ]	(* Omits cases of variable[n] that are not = 0 *)SelectPtNo[k_]:= Do[If[ v[1][[i]] == k,  , sel[[i]] = False ],					{i,1,numRows}					]	(* Selects cases for patient[k] *)SelectTime[tmin_,tmax_]:=		Do[ If[ 				N[ v[2][[i]] ] >=  tmin  &&  N[ v[2][[i]] ] <=  tmax,  , 						sel[[i]] = False],	{i,1,numRows}	];	(* If Dtime = v[2], select decimal time range *)	Case Number Range Selecton1-D and 2-D syntax(* Pattern matching for data input structure: ------ For 1-dimenstional list ------fun[data, {xmin, xmax, dx}] fun[list:{_?NumberQ...}, {xmin_?NumberQ, xmax_?NumberQ, dx_:1}] :=------- For 2-dimensional list ------fun[{{x1,y1}, {x2,y2}, ...}, {xmin, xmax, dx}, {ymin, ymax, dy}]fun[list:{{_?NumberQ...}...}, 		bins:{_?NumberQ, _?NumberQ, Optional[_, 1]}..] := *)(* Selecting cases manually overrides all other selections *)(* ----- 1-dimensional list ----- *)SelectCases[{min_?NumberQ, max_?NumberQ}]:= Module[{},		sel = selNone;		Do[ If[		casenum[[i]] >= min  &&  casenum[[i]] <= max,											sel[[i]] = True, Null ],		{i,1,numRows}		];	]	(* ----- 2-dimensional list ----- *)SelectCases[list:{{_?NumberQ,_?NumberQ}...}]:= Module[{},	sel = selNone;	Do[		Do[ If[		casenum[[i]] >= list[[j,1]]  &&  casenum[[i]] <= list[[j,2]],											sel[[i]] = True, Null],		{i,1,numRows}		],		{j,1,Length[list]}	]]Boolean SelectionMake the list of data pairs { sel[i], list[i] } by transposing the two vectors sel and list.				Transpose[{sel, list}]	Select[list, crit] picks out all elements ei of list for which crit[ei] is True.				Select[ {sel[i],list[i]}, First] applies First to the data pair {sel[i],list[i]}											First[{sel,lis}]			This evaluates to either True or False.			The pair {sel,lis} is picked based on this evaluation.	Map[f, expr] or f /@ expr applies f to each element on the first level in expr.					Map[Last, {sel[i],list[i]}]			 takes the last (second) element of the picked pair {s,l}.BoolSelect[list_List, sel_List] := 	Map[Last, Select[Transpose[{sel, list}], First]] /; 					Length[list] == Length[sel];Linear Fit / Regression(* built-in Fit[] function 10x faster than Regress[] package *)linfit[n_,m_]:=Module[{v1sel,v2sel,datsel,line},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				line = Fit[ Transpose[{v1sel,v2sel}],{1,x},x]		]		linA[n_,m_]:= linfit[v[n],v[m]] [[1]];linB[n_,m_]:= linfit[v[n],v[m]] [[2,1]];(* load external package for regression parameters *)<<RAFAEL:Apps:Mathematica:Packages:Statistics:LinearRegression.m(* Options[Regress]  *)linR2[n_,m_]:= Module[{v1sel,v2sel,datsel,reg },		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];			reg = Regress[datsel,{1,x},x,		OutputControl-> NoPrint,		OutputList->{RSquared} 		(*BestFitCoefficients,BestFit *)		];				(* {a,b}=BestFitCoefficients /. reg[[1]]  *)		RSquared /. reg[[1]]	]Plotting(* PlotStyle ->{Thickness[.001], GrayLevel[.2], Dashing[{.02,.02}] }  *)timePlottimePlot[n_]:=Module[{ymin,ymax,tsel,ysel,datsel},		vsel = BoolSelect[v[n],sel];		tsel = BoolSelect[v[2],sel];		datsel = Transpose[{tsel,vsel}];		ymin = Min[vsel];		ymax = Max[vsel];				ListPlot[datsel,				PlotJoined->True,				PlotRange ->{{0,8},{ymin,ymax}}				];		]xyPlotxyPlot[n_, m_]:=Module[{v1sel,v2sel,datsel},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				ListPlot[datsel,				PlotJoined->True ];		]xyScatterPlotxyScatterPlot[n_, m_]:=Module[{v1sel,v2sel,datsel},		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		datsel = Transpose[{v1sel,v2sel}];				ListPlot[datsel, Frame->True];		]		(* fitting  not working yet *)		m = 12;		n = 5;	(* variable: Ntemp *)		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		xmin = Min[v1sel]		xmax = Max[v1sel]				lindat = Transpose[{v1sel,v2sel}];		linfit = Fit[lindat,{1,x},x]		linslope = linfit[[2,1]] 		base = linfit /. x-> 37		normslope= linslope/base						logdat = Transpose[{v1sel,Log[v2sel]}];		logfit = Re[Fit[logdat,{1,1/x},x] ] /. x -> x+273		expfun = Exp[logfit] 		logslope = logfit[[2,1]]TempFitPlotTempFitPlot[m_]:=Module[				{v1sel,v2sel,xmin,xmax,lindat,linfit,linslope,base,				 normslope, logdat,logfit,expfun,logslope},				 		n = 5;	(* variable: Ntemp *)		v1sel = BoolSelect[v[n],sel];		v2sel = BoolSelect[v[m],sel];		xmin = Min[v1sel];		xmax = Max[v1sel];				lindat = Transpose[{v1sel,v2sel}];		linfit = Fit[lindat,{1,x},x];		linslope = linfit[[2,1]] ;		base = linfit /. x-> 37;		normslope= linslope/base;						logdat = Transpose[{v1sel,Log[v2sel]}];		logfit = Fit[logdat,{1,1/x},x] /. x -> x+273;		expfun = Exp[logfit] ;		logslope = logfit[[2,1]];				label1 = ToString[ linslope ];		label2 = ToString[ logslope ];		label3 = ToString[ base	];		label4 = StringDrop[ ToString[ normslope ],  -3];		label5 =StringJoin["lin:", label1," base:",label3,							" norm:",label4, " Arr:", label2];		xlabel = ToString[var[n]  ];		ylabel = ToString[var[m]  ];						fitplot =Plot[{linfit,expfun},{x,xmin,xmax},			PlotStyle->{				{Thickness[.001],GrayLevel[.1]},				{Thickness[.001],GrayLevel[.2], Dashing[{.01,.01}]}				},			Frame->True,			PlotLabel->label5,			FrameLabel->{xlabel,ylabel},			RotateLabel->False,			DefaultFont :> {"Courier",7},			DisplayFunction :> Identity 			];				dataplot = ListPlot[lindat,					DisplayFunction :> Identity  ];				Show[fitplot,dataplot,					DefaultFont :> {"Courier",8},					DisplayFunction :> $DisplayFunction ]		]		tempPlottempPlot[n_]:=Module[{v1sel,v2sel,datsel,selVar},		(* v2All = BoolSelect[v[v2],selAll]; *)		ymax  = Max[v[n] ];		ymin  = Min[v[n] ];				v1	  = 3; (* temperature varible *)		xmin  = 18;(* temp global min *)		xmax  = 40;(* temp global max *)				v1sel = BoolSelect[v[v1],sel];		v2sel = BoolSelect[v[n],sel];		datsel = Transpose[{v1sel,v2sel}];				DefaultFont -> {"Helvetica",7};		xlabel = ToString[vars[[v1]]  ];		ylabel = ToString[vars[[n]]  ];		plotlabel = StringJoin[xlabel," vs. ", ylabel ];				ListPlot[datsel,			PlotRange->{{xmin,xmax},{ymin,ymax}},			PlotLabel->FontForm[plotlabel,{"Courier-Bold",9}],			Frame->True,			FrameLabel->{xlabel,ylabel },			RotateLabel->False							]		]FitPlotFitPlot[eqn_]:=Module[{lindat,logdat,linfit,logfit, expfun,						base, linslope, logslope, normslope,						xlabel,ylabel},										lindat=Table[{x,eqn},{x,18,37,.5}];		logdat=Table[{x+273,Log[eqn]},{x,18,37,.5}];				linfit = Fit[lindat,{1,x},x];		logfit = Fit[logdat,{1,1/x},x] /. x -> x+273;		expfun = Exp[logfit] ;				base = linfit /. x-> 37;		linslope = linfit[[2,1]] ;		logslope = logfit[[2,1]];		normslope= linslope/base;				label1 = ToString[ linslope ];		label2 = ToString[ logslope ];		label3 = ToString[ base	];		label4 = StringDrop[ ToString[ normslope ],  -3];				label5 =StringJoin["lin:", label1," base:",label3,							" norm:",label4, " Arr:", label2];		(* plotlabel = FontForm[label3,{"Courier-Bold",8} ] *) 				xlabel = ToString["[C]"];		ylabel = ToString["[ms]"];				fitplot =Plot[{linfit,expfun},{x,18,37},			PlotStyle->{				{Thickness[.001],GrayLevel[.1]},				{Thickness[.001],GrayLevel[.2], Dashing[{.01,.01}]}				},			Frame->True,			PlotLabel->label5,			FrameLabel->{xlabel,ylabel},			RotateLabel->False,			DefaultFont :> {"Courier",7}			(*DisplayFunction :> Identity ,$DisplayFunction *)			 ]		]nullplot=Plot[ 0,{x,0,1},Axes->None,PlotStyle->{GrayLevel[1]}]Function Summarysel = selAll,selNone		(* resets selection vector of all cases *)n,m							(* variable(column) index numbers		*)				v[n]						(* data vector of variable n 			*)vars						(* prints out list of variables 		*)SelectYRange[n, ymin, ymax]	(* selects var[n] in range min to max 	*)SelectNonZero[n]			(* selects var[n] non-zero				*)SelectNonMissing[n]			(* selects var[n] non-missing 			*)SelectOFF[n]				(* selects var[n] = 0	   				*)SelectON[n]					(* selects var[n] = 1	   				*)SelectTime[tmin,tmax]		(* selects decimal time range 			*)SelectPtNo[k]				(* selects patient number k 			*)SelectCases[{min,max}]			(* select case[min] to case[max]	*)SelectCases[{{mini,maxi},..}]	(* select multiple ranges of cases 	*)BoolSelect[v[n], sel]		(* selects v[n] based on selection vector *)timePlot[n]					(* plot of v[n] vs. Dtime  				*)xyPlot[n, m]				(* line plot of v[n] vs var[m]			*)xyScatterPlot[n,m]			(* scatter plot of v[n] vs v[m] 		*)xyFitPlot[n,m]				(* scatter + linear fit of v[n] vs v[m] *)tempPlot[n]					(* scatter plot of Ntemp vs v[n] 		*)linfit[n,m]					(* linear fit equation: vm = a + b*vn 	*)linA[n,m]					(* intercept of linear fit 				*)linB[n,m]					(* slope of linear fit					*)linR2[n,m]					(* RSquare of linear fit 				*)Interpolation<<Graphics`Spline`?SplineExampleslinfit[3,10]SelectNonMissing[5]xyFitPlot[5,12];(* plot of all patients Ntemp *)Do[	sel=selAll;	SelectPtNo[i];	timePlot[v[3] ],	{i,1,14}	]^*)