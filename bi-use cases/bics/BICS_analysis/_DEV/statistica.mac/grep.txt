How Grep WorksThe "grep" mode of searching and replacing is a powerful tool. Althoughsomewhat slower than normal text searching, grep allows the user tosearch for one of a set of many strings instead of a particular string. As a simple example, you can search for any occurrence of an identifierbeginning with the letter P, or all lines that begin with a left brace.A pattern is a string of characters that, in turn, describes a set ofstrings of characters.  An example of a set of strings is the set of allstrings that begin with the letter P and end with the letter r;  thestrings "Ptr" and "ProcPtr" are members of this set.  We say that astring is matched by a pattern if it is amember of the set described bythe pattern.  Patterns are composed of sub-patterns which are patternsin themselves;  this is how complicated patterns may be formed.The following section goes through the grep pattern matching andreplacement rules step by step, so that by the end of it you should beable to understand how each of these grep patterns works and be able tomake your own.In some cases, the state of case sensitivity affects the results of apattern match.  We have noted below when this is the case.1. Any character, with certain exceptions described below, is a patternthat matches itself.2.	A pattern x followed by a pattern y forms a pattern xy that matchesany string Bu where B can be matched by x and u can be matched by y.  Wecan, of course, take the compound pattern xy and concatenate yet anotherpattern z onto it, forming the pattern xyz.3.	The character . is a pattern that will match any character.4.	The character \ followed by any character except one of the digits1-9 is a pattern that matches that character. (You would use this tofind special characters, such as the . character. To search for aperiod, you would use \.).5.	A string of characters s surrounded by square brackets ([ and a ])forms a pattern [s] that matches a single instance of one of thecharacters in the string s.  Note that the case sensitivity flag doesnot apply to characters between square brackets:  letters must matchexactly.5a.	 The pattern [^B] matches any character that is not in the stringB. Special characters will be taken literally in this context.  Again,case sensitivity doesn't apply to characters between square brackets.5b.	If a string of three characters in the form [a-b] occurs in thepattern p, this represents all of the characters from a to b inclusive. All special characters are taken literally;  i.e., [!-.] denotes thecharacters from ! to .. Notice that the only way to include thecharacter ] in p is to make it the very first character.  Likewise, theonly way to include the character - in p is to have it either at thevery beginning or the very end of p.  Single characters and ranges mayboth be used between brackets.6a.	Any pattern p formed by any combination of rules 1 or 3-5bfollowed by a * forms the pattern p* that matches zero or moreconsecutive occurrences of characters matched by p.6c.	Any pattern p formed by any combination of rules 1 or 3-5bfollowed by a ? forms the pattern p? that matches zero or oneconsecutive occurrences of characters matched by p.We now have the ability to form patterns that are composed ofsub-patterns, and will find it useful to "remember" sub-strings matchedby sub-patterns and to be able to match against those substrings.7.	A pattern surrounded by ( and ) is a pattern that matches whateverthe sub-pattern matches.  This is useful for matching two or moreinstances of the same string and when doing replacements.Sometimes it is useful to be able to "constrain" patterns to match only ifcertain conditions in the context outside the string matched are met.8.	A pattern p that is preceded by a ^ forms a pattern ^p.  If thepattern ^p is not preceded by any other pattern, it matches whatever pmatches as long as the first character matched by p occurs at thebeginning of a line.  If the pattern ^p is preceded by another pattern,then the ^ is taken literally.9.	A pattern p that is followed by a $ forms a pattern p$.  If thepattern p$ is not followed by any other pattern, it matches whatever pmatches as long as the last character matched by p occurs at the end ofa line.  If the pattern p$ is followed by another pattern, then the $ istaken literally.Note that the characters ^ and $ constrain pattern matches to begin orend at line boundaries, and so can be combined to constrain a pattern tomatch an entire line only (as in the above example).Grep provides not only a more sophisticated method of searching, but asophisticated method of replacing as well.  In a replacement string, thefollowing substitutions are made before any text replacement occurs:1.	Each occurrence of the character & is replaced with whatever waslast matched by the entire pattern.2.	Each occurrence of a string of the form \n, where n is one of thedigits 1-9, is replaced by whatever was last matched by the sub-patternbeginning with the nth occurrence of (.3.	Each occurrence of a string of the form \p, where p is other thanone of the digits 1-9, is replaced by p.This allows you to not only be able to search for a string satisfying acomplex set of conditions, but also to be able to do a subsequentreplacement that varies depending on the string that is matched. Notethat this does not take into account escape sequences, such as \t, \r,\n, \\, etc. Suppose that you have written a program that is to become aMacintosh application (i.e., it uses the Macintosh ToolBox instead ofstdio for the user interface).  Suppose also that you have discoveredthat you have forgotten to put a \p at the beginning of your stringconstants, so that your program is trying to pass C strings instead ofPascal strings to the Toolbox (which only knows how to deal with Pascalstrings).  You can easily change all your C strings to Pascal strings byspecifying "(.*)" as the search pattern and "\\p\1" as the replacementstring.Suppose you decided to reverse the two arguments of the function "foo". You might try the pattern foo\(  ([^,]*),([^)]*)  \) as the search patternand foo(\2, \1) as the replacement pattern.  How does the search patternwork?Let's assume we're trying to match some text that looks like foo(1,*bar)	foo\(   ([^,]*),  ([^)]*)   \)	matches	foo(1,*bar)Since ([^,]*) matched 1 and ([^)]*) matched *bar, the two arguments tofoo, the replacement pattern foo(\2, \1) will result in foo(*bar, 1)This, unfortunately, won't work in the case of foo(1,(*bar)+2), since([^)]*) will match only up to the first right parenthesis, leaving +2)unmatched.  If we're sure that all calls to foo end with a semicolon,however, we can change our pattern to foo\(([^,]*),([^;]*)\);. In thispattern, instead of trying to match the second argument by matchingeverything up to the first right parenthesis, we match everything up tothe ); which terminates the invocation of foo.In this example we showed how to analyze a grep pattern by examiningsub-patterns. This is a good way of figuring out how to build a patternas well. Grep can be thought of as a small and rather crypticprogramming language, with each pattern a program and sub-pattern astatement in this language. If you try to create a grep pattern bytesting a small sub-pattern, then adding and testing additionalsub-patterns until the complete pattern is built, you may find buildingcomplex grep patterns not nearly as daunting as you first thought.