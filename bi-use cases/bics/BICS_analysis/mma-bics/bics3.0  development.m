(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* Input["Enter File Name: "] //ToString; *)
(* streams:  String=linebuf \n; Word= wordbuf \t *)
(*  !!filename		display contents *)

(* Put relevant data and package files in path *)
(* MAC *)
$Path = Join[$Path, {"PB:Apps:Mathematica:Packages:Statistics "}];

(* WIN  
$Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\numerica\\"}];
$Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\graphics\\"}];
$Path = Join[$Path, {"c:\\richards\\wnmath22\\packages\\preload\\"}];
$Path = Join[$Path, {"c:\\richards\\bics"}];
filePath = "c:\\richards\\bics\\"
*)


(* -------- SET DIRECTORY -------------- *)
(*FileInformation["file"] *)
SetDirectory["Project:BICS:data"];



(*---------- TURN OFF SYMBOL WARNING pp386 SWolf ----*)
Off[General::newsym];


lineSeparator =
"------------------------------------------------------------------------------------\r";


(* ------DEFAULT VARIABLE NAMES-------*)
var = {	
		Hours, var2, var3, var4, var5, var6, var7, var8, var9, var10,
		var11, var12, var13, var14, var15, var16, var17, var18, var19, var20,
		var21, var22, var23, var24
		};





Clear[dir];
dir = Module[{dirname,dirs,files,numfiles},	
		dirname  = StringJoin["DIRECTORY:  ", Directory[] ];
		files 	 = FileNames[];
		dirs     = FileNames["*.*"];
		numfiles = StringJoin["FILES:      ", ToString[Length[files] ] ];
		numdirs	 = StringJoin["DIRS :      ", ToString[Length[dirs] ] ];
				
		Print[dirname];
		Print[numdirs];
		Print[numfiles];
		
		printList[files,6]//MatrixForm
		];


(* pad item list so the number of columns is integer divisor of 
total number of items *)

Clear[printNumList];
printNumList[ lis_List, printWidth_Integer ]:=Module[{},
	
	width=printWidth;	
	len=Length[lis];
	nulls = width - Mod[ len,width];
	nulltable = Table["-", {nulls}];
	lisPadded=Append[lis,nulltable]//Flatten;
		
	index=Table[i, {i, 1,Length[lisPadded] } ];

	pairs=Transpose[{index,lisPadded}];
	lines=Partition[pairs,width];
	Return[lines]
	]



Clear[printList];
printList[ lis_List, printWidth_Integer ]:=Module[{},
	
	width = printWidth;
	len=Length[lis];
	
	nulls = width - Mod[ len,width];
	nulltable = Table["-", {nulls}];
	lisPadded=Append[lis,nulltable]//Flatten;
	lines=Partition[lisPadded,width];
	Return[lines]
	]
	



(* EXTRA FUNCTIONS

----- calculate time var -----
	begT   =  data[[1,1]] ;
	endT   =  data[[dataRows,1]] ;
	deltaT = endT-begT;
	Print["Elapsed time: \t",deltaT];

----- display index,varname,firstval -----

outTable=Table[ StringJoin[
	"[",ToString[i],"] ",varNames[[i]],"\t",ToString[data[[1,i]] ]  ],
	{i,1,nCols}
	];
	
Return[ printList[outTable,3] //MatrixForm];
*)



readFileOut[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},
	
	Clear[nRows,nCols,varNames,data];

	stream1=OpenRead[fileName];
	SetStreamPosition[stream1,0];

(*----- read header -----*)
	nRows=Read[stream1, Number];
	nCols=Read[stream1, Number];

	Print["nRows: \t\t\t", nRows];
	Print["nCols: \t\t\t", nCols];
	
	varFormat=Table[Word, {nCols}];
	dataFormat=Table[Number,{nCols}];

(*----- read var names -----*)
	varNames=Read[ stream1, varFormat];
	Print["Vars: \t\t\t", varNames ];
	
(*---- read in data -----*)
	Print["reading rows..."];
	dataRows=0;
	data={{}};				(* create empty array *)
	For[i=1, i<=nRows,i++,
		line= Read[ stream1, dataFormat];
		
		If[ line[[1]] != -999,
			AppendTo[data, line];	(* probably spends much time
										allocating memory here... *)
			dataRows++
			,Null
			];		
		If[ Mod[i,500]==0, Print["\t\t\t\t",i] ];
		];
		
	nRows = dataRows;	
	Print["\t\t\t\t",nRows];
		
(*----- drop the first,empty, member of data -----*)
	data= Drop[data,1];	

	Print["\t\t\t\t","DONE READING FILE"];

];



readFileReg[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},
	
	Clear[nRows,nCols,nCases,nVars,varNames,data];
	
	stream1=OpenRead[fileName];
	SetStreamPosition[stream1,0];

(*----- read header -----*)
	nRows  = Read[stream1, Number];
	nCols  = Read[stream1, Number];
	nCases = Read[stream1,Number];
	nVars  = Read[stream1,Number];
	
	Print["nRows: \t\t\t", nRows];
	Print["nCols: \t\t\t", nCols];
	Print["nCases:\t\t\t", nCases];
	Print["nVars: \t\t\t", nVars];
	
	varFormat=Table[Word, {nVars}];
	dataFormat=Table[Number,{nCols}];

(*----- read var names -----*)
	varNames=Read[ stream1, varFormat];
	Print["varNames: \t\t", varNames ];
	
(*---- read in data -----*)
	Print["reading rows..."];
	dataRows=0;
	data={{}};				(* create array *)
	For[i=1, i<=nRows,i++,
		line= Read[ stream1, dataFormat];
		
		If[ line[[1]] != -999,
			AppendTo[data, line]; dataRows++,
			Null
			];		
		If[ Mod[i,500]==0, Print["\t\t\t\t",i] ];
		];
		
	nRows = dataRows;	
	Print["\t\t\t\t",nRows];
			
(*----- drop the first,empty, member of data -----*)
	data= Drop[data,1];	
	
	Print["\t\t\t\t","DONE READING FILE"]	

];



readFileLag[fileName_String]:=Module[{stream1,varFormat,dataFormat,dataRows},
	
	Clear[nRows,nCols,nCases,nVars,varNames,data];
	
	stream1=OpenRead[fileName];
	SetStreamPosition[stream1,0];

(*----- read header -----*)
	nRows  = Read[stream1, Number];
	nCols  = Read[stream1, Number];
	nCases = Read[stream1,Number];
	nVars  = Read[stream1,Number];
	
	Print["nRows: \t\t\t", nRows];
	Print["nCols: \t\t\t", nCols];
	Print["nCases:\t\t\t", nCases];
	Print["nVars: \t\t\t", nVars];
	
	varFormat=Table[Word, {nVars}];
	dataFormat=Table[Number,{nCols}];

(*----- read var names -----*)
	varNames=Read[ stream1, varFormat];
	Print["varNames: \t\t", varNames ];
	
(*---- read in data -----*)
	Print["reading rows..."];
	dataRows=0;
	data={{}};				(* create array *)
	For[i=1, i<=nRows,i++,
		line= Read[ stream1, dataFormat];
		
		If[ line[[1]] != -999,
			AppendTo[data, line]; dataRows++,
			Null
			];		
		If[ Mod[i,500]==0, Print["\t\t\t\t",i  ] ];
		];
		
	nRows = dataRows;	
	Print["\t\t\t\t",nRows];
			
(*----- drop the first,empty, member of data -----*)
	data= Drop[data,1];	
	
	Print["\t\t\t\t","DONE READING FILE"]	

];



selColsRows[data_,c1_,c2_,row1_,row2_]:=Module[{},

		v1=v2={};
		For[ i=row1, i<=row2, i++,
			
			If[ (data[[i,c1]] != -999) && (data[[i,c2]] != -999),
				AppendTo[ v1, data[[i,c1]] ];
				AppendTo[ v2, data[[i,c2]] ];
				];
			];
		
		Return[ {v1, v2}];
		]
			
	


Clear[selCaseCols3];
selCaseCols3[data_,caseNo_,c1_,c2_,c3_]:=Module[{i,v1,v2,v3,vars},

v1=v2=v3={};
For[ i=1, i<=nRows, i++,

	If[ data[[i,1]] == caseNo, 
		vars = {data[[i,2]], data[[i,3]] };
		If[data[[i,c1]] != -999 && data[[i,c2]] != -999 &&  data[[i,c3]] != -999,
			AppendTo[ v1, data[[i,c1]] ];
			AppendTo[ v2, data[[i,c2]] ];
			AppendTo[ v3, data[[i,c3]] ]	
		  ];
	  ];
   ];
   
{vars,v1, v2, v3 }//Return
];


Clear[selCaseCols2];
selCaseCols2[data_,caseNo_,c1_,c2_]:=Module[{i,v1,v2,vars},

v1=v2={};
For[ i=1, i<=nRows, i++,

	If[ data[[i,1]] == caseNo, 
		vars = {data[[i,2]], data[[i,3]] };
		If[data[[i,c1]] != -999 && data[[i,c2]] != -999,
			AppendTo[ v1, data[[i,c1]] ];
			AppendTo[ v2, data[[i,c2]] ];
		  ];
	  ];
   ];
   
{vars,v1, v2 }//Return
];


(* 	c1,c2:	column1, column2
	r1,r2:	row1, row2
	d1,d2:	first, second derivative cutoff values
*)

selColsRowsDeriv[data_,c1_,c2_,row1_,row2_,slope1_, slope2_]:=Module[{},

	(*----- eliminate missing data -----*)
	v1=v2={};
	For[ i=row1, i<=row2, i++,
		
		If[ (data[[i,c1]]!=-999) && (data[[i,c2]]!=-999),
			AppendTo[ v1, data[[i,c1]] ];
			AppendTo[ v2, data[[i,c2]] ];
			];
		];
		
	(*----- 1st & 2nd derivative test -----*)
	vec1=vec2={};
	For[i=2, i<= Length[v2]-1, i++,

		FLAG=1;	
		If[ Abs[v2[[i+1]] - v2[[i]]  ]  >= slope1,  			FLAG=0 ];
		If[ Abs[v2[[i]] - v2[[i-1]]  ]  >= slope1,  			FLAG=0 ];
		If[ Abs[v2[[i+1]] - 2 v2[[i]] + v2[[i-1]] ]  >= slope2,	FLAG=0 ];
	
		If[ FLAG != 0, 	AppendTo[ vec1, v1[[i]]  ];
						AppendTo[ vec2, v2[[i]]	 ], 	];
	
	];

Return[{vec1,vec2}];

]
			
	


plotVecs[v1_, v2_]:=Module[{},

	minV1=Min[ v1 ];
	maxV1=Max[ v1 ];
	lenV1=Length[v1];
	
	(*need min 5 non-missing points to plot *)	
		If[  lenV1 < 5, Print["N too small to plot"],	
		
			plotdat=Transpose[ {v1,v2}];	
			xlabel = "v1";
			ylabel = "v2";
			plotname=StringJoin["N: ",ToString[lenV1] ];
			
			ListPlot[ plotdat,
				PlotStyle->{PointSize[.001]},
				PlotRange->{minV1, maxV1};
				DefaultFont :> {"Courier",8},
				Frame -> True,
				PlotLabel-> plotname,
				FrameLabel->{xlabel,ylabel},
				RotateLabel->False
				]
			]		
	]




plotVecsMD[vec1_, vec2_]:=Module[{},

		v1=v2={};
		For[ i=1, i<=Length[vec1], i++,
			
			If[ (vec1[[i]] != -999) && (vec2[[i]] != -999),
				AppendTo[ v1, vec1[[i]] ];
				AppendTo[ v2, vec2[[i]] ];
				];
			];
		
	minV1=Min[ v1 ];
	maxV1=Max[ v1 ];
	lenV1=Length[v1];
	
	
	(*need min 5 non-missing points to plot *)	
		If[  lenV1  < 5, Print["N too small to plot"],	
		
			plotdat=Transpose[ {v1,v2}];	
			xlabel = "v1";
			ylabel = "v2";
			plotname=StringJoin["N: ",ToString[lenV1] ];
			
			ListPlot[ plotdat,
				PlotStyle->{PointSize[.001]},
				PlotRange->{minV1, maxV1};
				DefaultFont :> {"Courier",8},
				Frame -> True,
				FrameLabel->{xlabel,ylabel},
				PlotLabel-> plotname,				
				RotateLabel->False
				]
			]		
	]




plotCols[data_,c1_, c2_, r1_, r2_]:=Module[{},

	{v1,v2} = selColsRows[data,c1,c2,r1,r2];

	minV1=Min[ v1 ];
	maxV1=Max[ v1 ];
	lenV1=Length[v1];
	
	(*need min 5 non-missing points to plot *)	
		If[  lenV1 > 5,	
		
			plotdat=Transpose[ {v1,v2}];	
			xlabel = varNames[[c1]];
			ylabel = varNames[[c2]];
			plotname=StringJoin["N: ",ToString[lenV1] ];		
			
			ListPlot[ plotdat,
				PlotStyle->{PointSize[.001]},
				PlotRange->{minV1, maxV1};
				DefaultFont :> {"Courier",8},
				Frame -> True,
				FrameLabel->{xlabel,ylabel},
				PlotLabel-> plotname,						
				RotateLabel->False
				]
			]		
	];




plotColsDeriv[data_,c1_, c2_, r1_, r2_, slope1_, slope2_]:=Module[{},

	{v1,v2} = selColsRowsDeriv[data,c1,c2,r1,r2, slope1, slope2];

	minV1=Min[ v1 ];
	maxV1=Max[ v1 ];
	lenV1=Length[v1];
	
	(*need min 5 non-missing points to plot *)	
		If[  lenV1 > 5,	
		
			plotdat=Transpose[ {v1,v2}];	
			xlabel = varNames[[c1]];
			ylabel = varNames[[c2]];
			plotname=StringJoin["N: ",ToString[lenV1] ];
			
			ListPlot[ plotdat,
				PlotStyle->{PointSize[.001]},
				PlotRange->{minV1, maxV1};
				DefaultFont :> {"Courier",8},
				Frame -> True,
				FrameLabel->{xlabel,ylabel},
				PlotLabel-> plotname,						
				RotateLabel->False
				]
			]		
	];




plotSlopesR2[vars_,v1_, v2_, v3_]:=
	Module[{Nvalid,tCol,rCol,bCol,bMin,bMax,xMin,xMax,xRange,
			yMin,yMax,rLocal,theta,xLocal,yLocal,ptsEnd,ptsCenter,points,lines,
			xlabel,ylabel,plotlabel
			},

		Nvalid = Length[v1];
				
		If[ Nvalid <=3, Null,
				tCol = v1;
				bCol = v2;
				rCol = v3;

				tMin  = Min[tCol];
				tMax  = Max[tCol];				
				
				bMin  = Min[bCol];
				bMax  = Max[bCol];
			
				xMin  = Min[tCol];
				xMax  = Max[tCol];
				xRange = xMin-xMax;
				
				yMin  = Min[rCol];
				yMax  = Max[rCol];
				(*----------------------------*)
				rLocal   = 1.0;						(* radius of circle *)
				theta  = - ArcTan[bCol];
				xLocal = rLocal Cos[theta];
				yLocal = rLocal Sin[theta]/xRange;	(* scale y by xRange *)
	
				ptsEnd = Table[{{ tCol[[i]] + xLocal[[i]], rCol[[i]] + yLocal[[i]] },
							 { tCol[[i]] - xLocal[[i]], rCol[[i]] - yLocal[[i]] }},
					
							{i,1,Nvalid}
							];
							
				ptsCenter = Table[	{ tCol[[i]], rCol[[i]] },
								{i,1,Nvalid}
								];

				points = Prepend[Map[Point,ptsCenter],  AbsolutePointSize[3]  ];
				lines =  Prepend[Map[Line, ptsEnd],  AbsoluteThickness[.001]  ];
				(*----------------------------*)
				xlabel = "Hours";
				ylabel = "R^2";	
							
				plotlabel = StringJoin[	varNames[[ vars[[1]]  ]],
										" vs ",
										varNames[[  vars[[2]] ]],
										" // N:",
										ToString[Nvalid],
										"   B:",
										ToString[PaddedForm[bMin,{5,4}]],
										"...",
										ToString[PaddedForm[bMax,{5,4}]]
										];
										
					
				Show[ Graphics[points], Graphics[lines],
						PlotRange->{{tMin,tMax},{-0.1,1.0}},
						DefaultFont :> {"Courier",8},
						Frame -> True,
						FrameLabel->{xlabel,ylabel},
						RotateLabel -> False,
						PlotLabel->FontForm[plotlabel,{"Courier",8}]
					 ]
				]
			]
			
			(*
			PlotRange->{{xMin-1,xMax+1},{-0.1,1.0}},
			*)



plotLagR2[vars_,v1_, v2_]:=
	Module[{Nvalid,tCol,rCol,xMin,xMax,
			yMin,yMax,rLocal,theta,xLocal,yLocal,ptsEnd,ptsCenter,points,lines,
			xlabel,ylabel,plotlabel
			},

		Nvalid = Length[v1];
				
		If[ Nvalid <=3, Null,
							
				xMin  = Min[v1];
				xMax  = Max[v1];
				
				yMin  = Min[v2];
				yMax  = Max[v2];
				
				i=1;
				While[  v2[[i]] < yMax, i++];
				lagVal = v1[[i]];	
				
				(*----------------------------*)
				xlabel = "Lag";
				ylabel = "R^2";	
							
				plotlabel = StringJoin[	varNames[[ vars[[1]]  ]],
										" vs ",
										varNames[[  vars[[2]] ]],
										" // N:",
										ToString[Nvalid],
										"  R^2 :",
										ToString[PaddedForm[yMax,{5,4}]],
										"  Lag: ",
										ToString[ lagVal ]
										];

				plotdat=Transpose[ {v1,v2}];	

				ListPlot[ plotdat,
					PlotStyle->{PointSize[.001]},
					(* PlotRange->{{xMin,xMax},{-0.1,1.0}},  *)
					DefaultFont :> {"Courier",8},
					Frame -> True,
					FrameLabel->{xlabel,ylabel},
					RotateLabel->False,
					PlotLabel->FontForm[plotlabel,{"Courier",8}]
					]
			]
	]
			



plotFile[ filename_String ]:=Module[{extension},

	extension = StringTake[filename,-3];
	
	
	(*---   *.OUT  ----*)
	If[ StringMatchQ[ extension, "out" ],
		readFileOut[filename];

		For[ k=2, k<=nCols,k++,
			plotCols[data,1,k,1,nRows]
			]
		];
	
	
	(*---   *.REG   ---*)
	If[ StringMatchQ[ extension, "reg" ],
		readFileReg[filename];
	
		For[ k=1, k<=nCases,k++,
			{vars,v1,v2,v3}=selCaseCols3[data,k,4,5,6];
		
			plotSlopesR2[vars,v1,v2,v3]
			]
		];
		
	
	(*---   *.LAG   ---*)
	If[ StringMatchQ[ extension, "lag" ],
		readFileLag[filename];
	
		For[ k=1, k<=nCases,k++,
			{vars,v1,v2}=selCaseCols2[data,k,4,5];
		
			plotLagR2[vars,v1,v2]
			]
		];	
		
	]



(*
p005=ReadList["Mac:BICS:p005",{Number,Number}];
mu005 = Transpose[p005] [[1]];
t005 = Transpose[p005] [[2]];  *)



muCrit = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 
23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 
42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 
72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 105, 110, 115, 
120, 125, 130, 135, 140, 145, 150, 160, 170, 180, 190, 200, 250, 300, 350, 
400, 450, 500, 600, 700, 800, 900, 1000, 1000000};



t005 = {63.657, 9.925, 5.841, 4.604, 4.032, 3.707, 3.499, 3.355, 3.25, 
  3.169, 3.106, 3.055, 3.012, 2.977, 2.947, 2.921, 2.898, 2.878, 2.845, 2.845, 
  2.831, 2.819, 2.807, 2.797, 2.787, 2.779, 2.771, 2.763, 2.756, 2.75, 2.744, 
  2.738, 2.733, 2.728, 2.724, 2.719, 2.715, 2.712, 2.708, 2.704, 2.701, 2.698, 
  2.695, 2.692, 2.69, 2.687, 2.685, 2.682, 2.68, 2.678, 2.674, 2.67, 2.667, 
  2.663, 2.66, 2.657, 2.655, 2.652, 2.65, 2.648, 2.646, 2.644, 2.642, 2.64, 
  2.639, 2.637, 2.636, 2.634, 2.633, 2.632, 2.63, 2.629, 2.628, 2.627, 2.626, 
  2.623, 2.621, 2.619, 2.617, 2.616, 2.614, 2.613, 2.611, 2.61, 2.609, 2.607, 
  2.605, 2.603, 2.602, 2.601, 2.596, 2.592, 2.59, 2.588, 2.587, 2.586, 2.584, 
  2.583, 2.582, 2.581, 2.581, 2.5758};



Tcrit[dof_]:=Module[{},
	
	(* index of critical t-value *)
	iCrit[val_]:=		
		Do[ If[
			muCrit[[i]] <= val && muCrit[[i+1]] >= val,
					Return[i +1], Null
					],
			{i,0,Length[muCrit]-1}
			];
			
	Return[ t005[[ iCrit[dof]  ]]  ]
	
	]


(* If T>Tcrit then p>.005, and printed R2-> -500, a missing value *)
 
 R2[Xdat_,Ydat_]:=Module[{	Ndat,totDF,regDF,resDF,Xsum,Ysum,
 							XYsum,YYsum,XXsum,xySS,xxSS,yySS,
 							totSS,regSS,resSS,
 							totMS,regMS,resMS,Sxy,
 							b,Sb,t,rSqr,rSqrCrit	},
		
	vMean[list_List] := Apply[Plus, list] / Length[list];
	vSum[list_List]:=Apply[Plus, list];

	Ndat = Length[Xdat];	
	totDF = Ndat -1;
	regDF = 1;
	resDF = Ndat - 2;			(* residual DOF *)

(* PROTECT FROM NULL DATA *)
If[ Ndat <= 3, Return[-999],		
	
	Xsum = Xdat //vSum;
	Ysum = Ydat //vSum;
	
	XYsum = Xdat Ydat //vSum;
	YYsum = Ydat Ydat //vSum;
	XXsum = Xdat Xdat //vSum;
	
	xySS  = XYsum - (Xsum Ysum)/Ndat;
	xxSS  = XXsum - (Xsum Xsum)/Ndat;	(* xxSS *)
	yySS  = YYsum - (Ysum Ysum)/Ndat;
	
	totSS = yySS;
	regSS = (xySS)^2/xxSS;
	resSS = totSS - regSS;		(* residual sum of squares *)
	
	totMS = totSS/totDF;
	regMS = regSS/regDF;
	resMS = resSS/resDF;
	Sxy = Sqrt[resMS];

	(*VARIABLES
	b			slope
	Sb			SE: std error of estimate (of slope)
	rSqr		coeff of determination
	rSqrCrit	adjusted rSqr for p<.005 significance
	*)
	
	b     = xySS/xxSS;			
	Sb	  = Re[Sqrt[Sxy^2/xxSS]];	(* take real part *)
	If[ Sb==0, Sb= .000001 ]; 		(* avoid zero division *)
	t     = b/Sb;		
	rSqr  = regSS/totSS ;		
	
	
	(* 	CHECK CRITICAL T-VALUE: significance of R2 *)	
	(* if p>.005,  rSqrCrit -> -500(or -999) *)
	
	If[ t < Tcrit[resDF], rSqrCrit = -999,	rSqrCrit = rSqr];
	
	output={rSqrCrit,b};
	
	Return[output]
	]							
];






Clear[lagR2];
lagR2[v1_,v2_, lag_]:=Module[{},

	lenV=Length[v1];
	len= lenV-Abs[lag];

	If[len <=3, Print["N<3 data for lag: ",lag]; Return[{lag,-999}],
					
		v1Lag= Drop[v1, - Sign[lag] Abs[lag] ];	(*rotate left/right*)
		v2Lag= Drop[v2,   Sign[lag] Abs[lag] ];	(*rotate right/left*)
		
		result=R2[ v1Lag, v2Lag];
		Print[lag,"\t\t",result[[1]] ];
		Return[{lag, result[[1]]} ];	
		];
	];
	
	
