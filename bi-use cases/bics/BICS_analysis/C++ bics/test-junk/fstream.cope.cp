//the problem starts here:// It appears to me that the main problem you are having is that theiostreams are not// really intended for random I/O -- they are intended for reading in or spewing out a continuous// stream of data.  You may be better off using the stdio stuff if you really need to jump around// in the file.  If you want to random I/O with streams, it appears you need to play with the// stream buffer, which you can get by calling rdbuf().  Below is how I got it to work.  Keep// in mind that I am no ANSI streams expert, so there may be better ways, but just  from looking at// the headers, this one was the most obvious.  I could not find any methods called 'seekp' or// 'seekg' anywhere in the ANSI headers included with CW 8.  I did find them in the iostream// stuff included with MPW, however.  It may be worth sending a message to them in the iostream// them about it.//ifstream letters( "LETTERS.DAT", ios::in | ios::out );//    --you can't write to an ifstreamofstream letters( "LETTERS.DAT", ios::in | ios::out );letters.rdbuf()->pubseekoff(8, ios::beg);   //letters.seekp(8, ios::beg);for (char letter ='I'; letter <='Z'; letter++)        letters << letter;letters.rdbuf()->pubseekoff(0, ios::beg);   //letters.seekg(0, ios::beg);//while (! letters.eof())// cout.put((char)letters.get());for(char x =(char)letters.rdbuf()->sgetc(); x !=EOF;        x =(char)letters.rdbuf()->snextc())                cout.put(x);// Note: doing this you may not be able to call letters.eof().  For this part, you would be// better off using an ifstream and calling its get() method.  I just did this to illustrate// how you might read and write using 1 stream.letters.close();// You could also use two streams as illustrated below.  Note that you MUST flush the output stream// before using the input stream or things will get really goofy.  This could be difficult to// manage, depending on what you are doing.//// Note:  This doesn't work because of what appears to be a bug that keeps the ifstream from// detecting the end of file.  You may want to play with that some and see if you notice the same// thing.  If so, send it to Metrowerks as a bug./*ifstream iletters( "LETTERS.DAT");ofstream oletters( "LETTERS.DAT", ios::in | ios::out); // must be in and outoletters.rdbuf()->pubseekoff(8, ios::beg);   //letters.seekp(8, ios::beg);for (char letter ='I'; letter <='Z'; letter++)oletters << letter;oletters.flush(); //must do this before reading.while (!iletters.eof()) {        //there seems to be a bug in CW 8 that keeps it from detecting the eof	char x;	iletters >> x;	cout.put(x);	iletters >> x;	cout.put(x);	}iletters.close();oletters.close();*/}