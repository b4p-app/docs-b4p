/*Title:			parser.cpPurpose:		removes specified columns from data file and 				writes a new data file with -999 as missing valuesFile Format:	input file must be saved as DOS format				the newline "\n" is not read if is mac formatAuthor:			RMRDate:			4.30.96*/#include <iostream.h>				// cin,cout#include <stdio.h>					// NR headers#include <stddef.h>#include <stdlib.h>#include <strstream.h>				//string streams#include <fstream.h>				//stream manager#include <ctype.h>					//isalpha, isspace#define  NRANSI						//must have in order to load memory.cp#include "nr_util.h"				//RMR-NRUTIL#include "nr_util.cp"				//RMR-NRUTIL#include "raf_util.cp"#include "raf_util.h"void main(void){	char			ans[40];		//1 word = 40-character array	char			ansYN;			//single char answer	char 			line[1024];		//line buffer, holds 1024 chars										//    but grabs up to nullterm (\0) only	char			filename[40];	//file name, max length 40 chars	int				i,j,k = 0;		//counters	char			word[20];		//word = 20-character array	float			value=0;		//data value	long int		ROWS=0L;		//num rows	int				COLS1,COLS2,COLS;//num cols in first and second rows	double			hr,min,sec,dtime;//time vars	int				timeQ=0;		//flag for existence of time field(default:OFF)	int 			varSel[40]={0};	//variable name selection vector	int 			colSel[40]={0};	//data column selection vector	int				nColsSel;		//number of cols selected for output	int				nColsOut;		//number of cols actually output	long int		colMD[40]={0L};	//missing data count of selected cols	char*			rest;			//leftover(Non-numerical) from strtod lib call	char** 			wordArray;		//define pointer to word pointers	wordArray = matrixChar(1,100,1,20);//allocate memory for 100 word pointers	char**			varNames;	varNames  = matrixChar(1,100,1,20);	int 			wordcount=0;	//word counter					int				colons=0;		//colon count	int				colonLoc[4];	//colon locations, in words	//startup message cout<<pageUp<<"   *****************************************************************"<<endl<<"   *                                                               *"<<endl	<<"   *                      FILE PARSER                              *"<<endl<<"   *                                                               *"<<endl	<<"   *   Recognizes mixed mode data with various delimiters.         *"<<endl<<"   *   Columns may be selected and exported in any order.          *"<<endl<<"   *   Missing data are assigned a float value of -999.            *"<<endl<<"   *   If there is a time field hh:mm:ss it is detected            *"<<endl<<"   *   and may be selected for export as decimal hours.            *"<<endl<<"   *   All data are checked for valid bounds and assigned          *"<<endl<<"   *   missing values outside this range 0-200.                    *"<<endl<<"   *   NB: Input file must be saved as DOS format - the            *"<<endl<<"   *   newline character is not read if is mac format.             *"<<endl<<"   *                                                               *"<<endl	<<"   *                                                               *"<<endl	<<"   *                                                               *"<<endl	<<"   *                    Copyright 1996                             *"<<endl	<<"   *                Rafael M. Richards, M.S.                       *"<<endl	<<"   *                George I. Chovanes, M.D.                       *"<<endl	<<"   *****************************************************************"<<endl<<"\n\n";		//open input stream	cout<< "Enter input file name ==>";	cin >> filename;		//"dir:subdir:filename"	ifstream	INFILE0;						INFILE0.open (filename, ios::in);	if 	( INFILE0.fail() )  nrerror("error opening file");		else		{		cout	<<"first two rows:"<<endl<<lineSeparator<<endl;		for (i=0 ;i<2; i++)			{			ROWS++;			INFILE0.getline( line, sizeof(line) );			cout	<<line<<endl<<lineSeparator<<endl;			};		cout<<"Reading rows (x100)";		while ( ! INFILE0.eof()  )			{			ROWS++;			INFILE0.getline( line, sizeof(line) );			if(  ( ROWS % 100 )== 0) cout<<".";				}		}	INFILE0.close();	ROWS = ROWS-1;	cout<<ROWS<<endl;//open instream to file again	ifstream	INFILE(filename, ios::in);//get and process first data line			INFILE.getline(line, sizeof(line) );	ToWords(line, varNames,wordcount,colons, colonLoc);	COLS1 = wordcount;		//get and process second line of data	INFILE.getline(line,sizeof(line) );		ToWords(line, wordArray, wordcount,colons, colonLoc);		COLS2 = wordcount;		//if only 2 colons and they are adjacent, then time field exists		if( (colons == 2) && ( colonLoc[1] +1 == colonLoc[2]) )		{				timeQ=1;					//time field exits: flag=ON			cout<<"NOTE: A TIME FIELD WAS DETECTED."<<endl;							//calculation of DTIME, using string to double		hr  = strtod( wordArray[ colonLoc[1]   ], &rest  );		min = strtod( wordArray[ colonLoc[1]+1 ], &rest  )/ 60;		sec = strtod( wordArray[ colonLoc[1]+2 ], &rest  )/3600;		dtime= (hr+min+sec);		//if replace 3 time fields by dtime reduce total cols by 2		// 	INDEXING:			visible i		value		//	i<colonLoc[1] 		   [i]			wordArray[i]		//	i=colonLoc[1]		   [i]			dtime		//  i>colonLoc[1]  i=+3;   [i-2]		wordArray[i]		//if simply deleting time fields		//reduce total cols by 3, then re-index to skip omitted cols				COLS2 = COLS2 - 3;				//adjusted total data cols		}	//display file stats and messages	//default number of columns is number of variables in row1	COLS=COLS1;		//but COLS is the smaller of COLS1 and COLS2 if they are unequal	if(COLS1 != COLS2)		{		cout<<"NOTE: NUMBER OF COLUMNS UNEQUAL IN FIRST TWO ROWS: "			<<"("<<COLS1<<") and ("<<COLS2<<")"<<endl;		if( COLS1 < COLS2 ) 		COLS=COLS1;		else						COLS=COLS2;		}		//cout<<"ROWS : "<<ROWS<<endl;	//cout<<"COLS : "<<COLS<<endl;	cout<<lineSeparator<<endl;		//print out first two rows as   [colNum]colName value			if(timeQ)		{			for(i=1;i<colonLoc[1]; i++) 			{			cout<<"["<<i<<"]"<<varNames[i]<<" "<< wordArray[i]<<"\t\t";			if( (i % 3)==0 ) cout<<endl;			}		for(i=colonLoc[1]+3; i<=COLS+3; i++) 			{			cout<<"["<<i-3<<"]"<<varNames[i-3]<<" "<< wordArray[i]<<"\t\t";			if( ( (i-3)%3)==0 ) cout<<endl;			}		}	else		{			for(i=1; i<=COLS; i++) 			{			cout<<"["<<i<<"]"<<varNames[i]<<" "<< atof(wordArray[i])<<"\t\t";				if( (i % 3)==0 ) cout<<endl;			}		}	cout<<endl<<lineSeparator<<endl;										//select columns to export	cout<<"List columns to export      ==>";	cin>>ans;					//cin.getline(ans) - avoid preceeding whitespace	ToWords(ans, wordArray, wordcount,colons, colonLoc);	nColsSel=wordcount;	for(i=1;i<=nColsSel;i++)		{		colSel[i]= atoi( wordArray[i] );	//string to integer lib function		varSel[i]= colSel[i];		;		//cout<<"["<<varNames[ varSel[i] ]<<"]"<<"\t";		}//re-index colSel so it skips past the time fields	if(timeQ)		{		for(j=1; j<=nColsSel; j++) 			{			if( colSel[j] >= colonLoc[1] ) colSel[j] = colSel[j]+ 3;			}			}//open output stream	char ofilename[40];						//output file name 40 char	cout<<"Enter output file name      ==>";	cin>>ofilename;	ofstream	OUTFILE( ofilename, ios::out);	if 	( OUTFILE.fail() )  nrerror("error opening output file");		//rewind input stream to zero offset from beginning.	//streampos pos = INFILE.tellg();	//cout<<"streampos:"<<pos<<endl;	INFILE.seekg(0, ios::beg);	char namesQ='a';		while( (namesQ !='Y') && (namesQ != 'N') )		{		cout<<"Output variable names?(Y/N) ==>"; 		cin >> namesQ ;  		namesQ = toupper(namesQ);		}	if( timeQ )		{		ansYN='a';			while( (ansYN !='Y') && (ansYN != 'N') )			{			cout<<"Output decimal time?(Y/N)   ==>"; 			cin >> ansYN ;  			ansYN = toupper(ansYN);			}		}	if( ansYN == 'Y' )  timeQ=1;	//keep flag on			if( ansYN == 'N' )  timeQ=0;	//turn off flag for dtime output//write header to output file	nColsOut = nColsSel;	if( timeQ )	nColsOut=nColsSel+1;		OUTFILE<<ROWS-2<<"\t"<<nColsOut<<endl;				//get and process first line as names					if ( namesQ == 'Y')		{									INFILE.getline(line,sizeof(line) );		ToWords(line, wordArray, wordcount,colons, colonLoc);		if( timeQ)			{			OUTFILE<<"DTime\t";				}		for(j=1; j<=nColsSel; j++)			{			if( j < nColsSel )				OUTFILE<< varNames[ varSel[j] ] <<"\t";			else				OUTFILE<< varNames[ varSel[j] ] <<"\n";				}		}							//read and write until end of file	cout<<"Writing rows(x100)";	for(i=1; i<ROWS; i++)			//get and process lines as numbers			{		INFILE.getline(line,sizeof(line) );		ToWords(line, wordArray, wordcount,colons, colonLoc);		if(  (i % 100)== 0) cout<<".";							if( timeQ )			{				hr  = strtod( wordArray[ colonLoc[1]   ], &rest  );			min = strtod( wordArray[ colonLoc[1]+1 ], &rest  )/ 60;			sec = strtod( wordArray[ colonLoc[1]+2 ], &rest  )/3600;			dtime= (hr+min+sec);			OUTFILE<<fixed<<dtime<<"\t";			}		for(j=1; j<=nColsSel; j++)			{			value=atof( wordArray[ colSel[j] ] );			//threshold clean non-missing values < 0			if( (value<0) || (value == -999) )				{				colMD[j]++;				value = -999;				}			if( j < nColsSel )				OUTFILE	<< value <<"\t";			else				OUTFILE << value <<"\n";			}		}	cout<<endl<<lineSeparator<<endl		<<"Number of missing or out of range values out of total "<<ROWS<<":"<<"\n\n";		//<<"COLS: "<<nColsOut<<endl<<"ROWS: "<<ROWS-1<<endl;			for(j=1; j<=nColsSel; j++) 		{		cout<<"["<<varNames[ varSel[j] ]<<"]"<<colMD[j]<<"\t\t";		if( ( j % 3)==0 ) cout<<endl;		}		OUTFILE.close();INFILE.close();nrerror("Finished writing. Press <return> to close window.");return;				//nothing: main's type is void}			