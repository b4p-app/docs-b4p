//override new and delete operators: Jamsa pp 216// TO DO: use function templates,  pp 171 Jamsa// template <class T> ;  T = float,int,double,long during runtime#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */#include <iostream.h>		// cin,cout#include <stdio.h>			// NR headers#include <stddef.h>#include <stdlib.h>#define NR_END 1				#define FREE_ARG char*			/*  ----------------------- ERROR HANDLING--------------------------- */void nrerror(char error_text[])			{	cerr<<"\n__________________"<<endl		<< error_text <<endl		<<"...EXITING PROGRAM.\n";	exit(1);					// stdlib exit	}	/*  -------------------- ALLOCATE MEMORY ------------------------ *///allocate space for DIM floats in application heap (free store) //don't allocate within a function (local memory) b.c. it cannot be freed after//function exits. Each function call would take further memory away from heap.float* vector(long nl, long nh)/* allocate arbitrary offset float vector v[nl..nh] */{	long  DIM = nh-nl+1+NR_END;	cout	<< "vector elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		   	float *v;	v=( float *) new float [DIM];	if (v == NULL)  nrerror("allocation failure for vector()");		//return pointer to float array v	return v-nl+NR_END;}char* vectorChar(long nl, long nh)/* allocate arbitrary offset float vector v[nl..nh] */{	long  DIM = nh-nl+1+NR_END;	cout	<< "char vector elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( char ) + 96)/1000  <<" Kb)"<< endl;   		   	char *v;	v=( char *) new float [DIM];	if (v == NULL)  nrerror("allocation failure for vector()");		//return pointer to float array v	return v-nl+NR_END;}float* subvector(float** data, long col, long nl, long nh)/* select column from data matrix and allocate vector [1...nrow]  pointing to col[nl...nh] */{	long 	i,k, nrow=  nh - nl + 1;	long	DIM = nrow+NR_END;	cout 	<< "subvector elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;		/* allocate array of pointers */	float*  v;	v=(float*)  new float [nrow+NR_END];	if (!v) nrerror("allocation failure in subvector()");	v += NR_END;		/* set pointers to rows */	for(i=1, k=nl; i<= nrow; i++, k++)  v[i]= data[ k ][col];	return v;}	float**  matrix(long nrl, long nrh, long ncl, long nch)/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */{	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;	long	DIM = nrow*ncol;	cout 	<< "matrix elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;	/* allocate pointers to rows */	float**  m;	m=(float**)  new float [nrow+NR_END];	if (!m) nrerror("allocation failure 1 in matrix()");	m += NR_END;	m -= nrl;	/* allocate rows and set pointers to them */	m[nrl]=(float*)  new float [nrow*ncol+NR_END];	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");	m[nrl] += NR_END;	m[nrl] -= ncl;	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;	/* return pointer to array of pointers to rows */	return m;}char**  matrixChar(long nrl, long nrh, long ncl, long nch)/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */{	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;	long	DIM = nrow*ncol;	cout 	<< "char matrix elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( char ) + 96)/1000  <<" Kb)"<< endl;	/* allocate pointers to rows */	char**  m;	m=(char**)  new float [nrow+NR_END];	if (!m) nrerror("allocation failure 1 in matrix()");	m += NR_END;	m -= nrl;	/* allocate rows and set pointers to them */	m[nrl]=(char*)  new char [nrow*ncol+NR_END];	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");	m[nrl] += NR_END;	m[nrl] -= ncl;	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;	/* return pointer to array of pointers to rows */	return m;}float** submatrix(float** a, long oldrl, long oldrh, long oldcl, long oldch,				long newrl, long newcl)/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */{	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;	long	DIM = nrow+NR_END;	cout 	<< "submatrix elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;	/* allocate array of pointers to rows */	float** m;	m=(float**)  new float [nrow+NR_END];	if (!m) nrerror("allocation failure in submatrix()");	m += NR_END;	m -= newrl;	/* set pointers to rows */	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;	/* return pointer to array of pointers to rows */	return m;}float** convert_matrix(float* a, long nrl, long nrh, long ncl, long nch)/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrixdeclared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1and ncol=nch-ncl+1. The routine should be called with the address&a[0][0] as the first argument. */{	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;	long	DIM = nrow+NR_END;	cout 	<< "convert_matrix elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;	/* allocate pointers to rows */	float** m;	m=(float**)  new float [nrow+NR_END];	if (!m) nrerror("allocation failure in convert_matrix()");	m += NR_END;	m -= nrl;	/* set pointers to rows */	m[nrl]=a-ncl;	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;	/* return pointer to array of pointers to rows */	return m;}float*** f3tensor(long nrl, long nrh,long ncl,long nch,long ndl,long ndh)/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */{	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;	long	DIM = nrow*ncol*ndep;	cout 	<< "f3tensor elements allocating:\t" << DIM   		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		/* allocate pointers to pointers to rows */	float*** t;	t=(float***) new float [nrow+NR_END];	if (!t) nrerror("allocation failure 1 in f3tensor()");	t += NR_END;	t -= nrl;	/* allocate pointers to rows and set pointers to them */	t[nrl]=(float **) new float [nrow*ncol+NR_END];	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");	t[nrl] += NR_END;	t[nrl] -= ncl;	/* allocate rows and set pointers to them */	t[nrl][ncl]=(float *) new float [nrow*ncol*ndep+NR_END] ;	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");	t[nrl][ncl] += NR_END;	t[nrl][ncl] -= ndl;	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;	for(i=nrl+1;i<=nrh;i++) {		t[i]=t[i-1]+ncol;		t[i][ncl]=t[i-1][ncl]+ncol*ndep;		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;	}	/* return pointer to array of pointers to rows */	return t;}/*  ------------------------ RELEASE MEMORY---------------------------- */void free_vector(float* v, long nl, long nh)/* free vector allocated with vector() */		{	long  DIM = nh-nl+1+NR_END;	cout 	<< "vector elements deleting:\t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		delete((FREE_ARG) (v+nl-NR_END ) );	}void free_subvector(float* v, long nl, long nh)/* free vector allocated with subvector() */		{	long 	nrow=  nh - nl + 1;	long	DIM = nrow+NR_END;	cout 	<<"subvector elements deleting:\t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;		delete((FREE_ARG) (v-NR_END ) );	}		void free_matrix(float** m, long nrl, long nrh, long ncl, long nch)/* free a float matrix allocated by matrix() */{	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;	long	DIM = nrow*ncol;	cout 	<<"matrix elements deleting:\t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		delete((FREE_ARG) (m[nrl]+ncl-NR_END));	delete((FREE_ARG) (m+nrl-NR_END));}void free_submatrix(float** b, long nrl, long nrh, long ncl, long nch)/* free a submatrix allocated by submatrix() */{	long i,j,nrow=nrh-nrl+1,ncol=ncl-ncl;	long	DIM = nrow+NR_END;	cout 	<<"submatrix elements deleting:\t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		delete((FREE_ARG) (b+nrl-NR_END));}void free_convert_matrix(float** b, long nrl, long nrh, long ncl, long nch)/* free a matrix allocated by convert_matrix() */{	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;	long	DIM = nrow+NR_END;	cout 	<<"convert_matrix elements deleting:\t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		delete((FREE_ARG) (b+nrl-NR_END));}void free_f3tensor(float*** t, long nrl, long nrh,long ncl,long nch,long ndl,long ndh)/* free a float f3tensor allocated by f3tensor() */{	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;	long	DIM = nrow*ncol*ndep;	cout 	<< "\t f3tensor elements deleting: \t" << DIM		<<" ( "   		<< ( DIM*sizeof( float ) + 96)/1000  <<" Kb)"<< endl;   		delete((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));	delete((FREE_ARG) (t[nrl]+ncl-NR_END));	delete((FREE_ARG) (t+nrl-NR_END));}#endif /* ANSI */