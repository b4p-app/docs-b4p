/* *** FUNCTION:	regressVecs** Given a set of data points x[1...ndata], y[1...ndata], fit them to a * straight line y = a + bx. Returned are slope (b), standard error estimate * of slope (sigb), coefficient of determination (rSquare), and t-value (tval).***/#include "tcrit.cp"#include <math.h>void regress(float x[], float y[], int ndata, int lag,float *b, 			float *sigb, float *rSqr, float *tval , float *tcrit ){	int		i,nlag=0;		float	totDOF,regDOF,resDOF,			sx=0.0,sy=0.0,sxy=0.0,syy=0.0,sxx=0.0,			ssxy,ssxx,ssyy, 			totSS,regSS,resSS, 			totMS,regMS,resMS,Sxy;		nlag = abs(lag);			//number of lags	ndata = ndata - nlag;		//adjusted number of data points	if (ndata <= 5) cout<<"WARNING: number of data points < 5."<<endl;//increment pointers to lag data	if(lag>0) {		for(i=1;i<=nlag;i++) 	y++;	}	if(lag<0) {		for(i=1;i<=nlag;i++)	x++;	}//begin calculations 	totDOF = ndata -1;			//total DOF	regDOF = 1;					//regression DOF	resDOF = ndata - 2;			//residual DOF		for (i=1;i<=ndata;i++) {		sx += x[i];		sy += y[i];		sxy += ( x[i] * y[i] );		syy += ( y[i] * y[i] );		sxx += ( x[i] * x[i] );	}	ssxy  = sxy - (sx*sy)/ndata;		//sum of squares	ssxx  = sxx - (sx*sx)/ndata;	ssyy  = syy - (sy*sy)/ndata;		totSS = ssyy;						//sum of squares	regSS = (ssxy*ssxy)/ssxx;	resSS = totSS - regSS;					totMS = totSS/totDOF;				//mean squares	regMS = regSS/regDOF;	resMS = resSS/resDOF;	Sxy =  sqrt(resMS);		*b		= ssxy/ssxx;				*sigb	= sqrt(Sxy*Sxy/ssxx) ;		//take real part-implicit	if( *sigb==0 ) *sigb= .000001 ; 	//avoid zero division	*tval	= abs( *b/(*sigb) );			*rSqr	= regSS/totSS ;	//external function call	*tcrit = tCrit(totDOF);							//restore pointers to data	if(lag>0) {			for(i=1;i<=nlag;i++) 	y--;	}	if(lag<0) {			for(i=1;i<=nlag;i++) 	x--;	}	}